/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RelatedNotesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/ui.ts
var import_obsidian = require("obsidian");
var RELATED_NOTES_VIEW_TYPE = "related-notes-view";
var RelatedNotesView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.plugin = plugin;
  }
  getViewType() {
    return RELATED_NOTES_VIEW_TYPE;
  }
  getDisplayText() {
    return this.plugin.settings.customTitle;
  }
  getIcon() {
    return "zap";
  }
  async onOpen() {
    if (!this.containerEl.children[1]) {
      this.containerEl.createDiv();
    }
    const container = this.containerEl.children[1];
    container.empty();
    this.containerEl.addClass("related-notes-container");
    container.createDiv({ cls: "related-notes-content" });
  }
  async onClose() {
    this.containerEl.empty();
    this.containerEl.removeClass("related-notes-container");
    this.currentFile = null;
  }
  async reset() {
    const fragment = document.createDocumentFragment();
    const contentEl = fragment.createEl("div", { cls: "related-notes-content" });
    contentEl.createEl("h4", { text: this.plugin.settings.customTitle, cls: "related-notes-title" });
    const messageEl = contentEl.createDiv({ cls: "related-notes-message" });
    messageEl.createEl("p", {
      text: "Open a markdown file to see related notes.",
      cls: "related-notes-message-text"
    });
    const container = this.containerEl.children[1];
    container.empty();
    container.appendChild(fragment);
  }
  /**
   * Checks if a link to the target file exists in the source file content
   */
  async hasLink(sourceFile, targetFile) {
    try {
      const content = await this.app.vault.cachedRead(sourceFile);
      const wikiLinkPattern = new RegExp(`\\[\\[${targetFile.basename}(\\|[^\\]]*)?\\]\\]`, "i");
      const markdownLinkPattern = new RegExp(`\\[.*?\\]\\(${targetFile.basename}\\.md\\)`, "i");
      const fullPathPattern = new RegExp(`\\[\\[${targetFile.path.replace(/\./g, "\\.")}(\\|[^\\]]*)?\\]\\]`, "i");
      return wikiLinkPattern.test(content) || markdownLinkPattern.test(content) || fullPathPattern.test(content);
    } catch (error) {
      console.error(`Error checking for links in ${sourceFile.path}:`, error);
      return false;
    }
  }
  /**
   * Adds a link to the target file at the end of the source file
   * Checks for existing links to avoid duplicates
   */
  async addLink(sourceFile, targetFile) {
    try {
      const content = await this.app.vault.cachedRead(sourceFile);
      const linkExists = await this.hasLink(sourceFile, targetFile);
      if (linkExists) {
        return;
      }
      const linkText = `

## ${this.plugin.settings.customTitle}
- [[${targetFile.basename}]]
`;
      const relatedSectionRegex = new RegExp(`\\n## ${this.plugin.settings.customTitle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\n`);
      let newContent;
      if (relatedSectionRegex.test(content)) {
        const existingLinkRegex = new RegExp(`- [[${targetFile.basename.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}]]`, "i");
        if (existingLinkRegex.test(content)) {
          return;
        }
        const escapedTitle = this.plugin.settings.customTitle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        newContent = content.replace(
          new RegExp(`\\n## ${escapedTitle}\\n((?:- \\[\\[[^\\]]+\\]\\]\\n)*)`),
          (match, p1) => `
## ${this.plugin.settings.customTitle}
${p1}- [[${targetFile.basename}]]
`
        );
      } else {
        newContent = content + linkText;
      }
      await this.app.vault.modify(sourceFile, newContent);
    } catch (error) {
      console.error(`Error adding link to ${sourceFile.path}:`, error);
      throw error;
    }
  }
  async updateForFile(file, notes) {
    const fragment = document.createDocumentFragment();
    const contentEl = fragment.createEl("div", { cls: "related-notes-content" });
    contentEl.createEl("h4", { text: this.plugin.settings.customTitle, cls: "related-notes-title" });
    this.currentFile = file;
    if (!this.plugin.isMarkdownFile(file)) {
      const messageEl = contentEl.createDiv({ cls: "related-notes-message" });
      messageEl.createEl("p", {
        text: "Related notes are only available for markdown files.",
        cls: "related-notes-message-text"
      });
      messageEl.createEl("p", {
        text: `Current file type: ${file.extension.toUpperCase()}`,
        cls: "related-notes-message-subtext"
      });
      const container2 = this.containerEl.children[1];
      container2.empty();
      container2.appendChild(fragment);
      return;
    }
    if (!notes.length) {
      const messageEl = contentEl.createDiv({ cls: "related-notes-message" });
      if (!this.plugin.isInitializationComplete()) {
        messageEl.createEl("p", {
          text: "Still analyzing your notes...",
          cls: "related-notes-message-text"
        });
        messageEl.createEl("p", {
          text: "Related notes will appear here once indexing is complete.",
          cls: "related-notes-message-subtext"
        });
      } else {
        messageEl.createEl("p", {
          text: "No related notes found.",
          cls: "related-notes-message-text"
        });
      }
      const container2 = this.containerEl.children[1];
      container2.empty();
      container2.appendChild(fragment);
      return;
    }
    const isLargeVault = this.app.vault.getMarkdownFiles().length > 1e3;
    const listEl = contentEl.createEl("ul", { cls: "related-notes-list" });
    const listItems = notes.map((note) => {
      const { file: relatedFile } = note;
      const listItemEl = document.createElement("li");
      listItemEl.className = "related-note-item";
      const itemContainer = document.createElement("div");
      itemContainer.className = "related-note-item-container";
      const linkContainer = document.createElement("div");
      linkContainer.className = "related-note-link-container";
      const nameEl = document.createElement("span");
      nameEl.className = "related-note-link";
      nameEl.textContent = relatedFile.basename;
      nameEl.title = relatedFile.basename;
      linkContainer.appendChild(nameEl);
      linkContainer.addEventListener("click", async () => {
        try {
          const leaf = this.app.workspace.getLeaf();
          if (!leaf)
            return;
          await leaf.openFile(relatedFile);
        } catch (error) {
          console.error(`Error opening file ${relatedFile.path}:`, error);
        }
      });
      itemContainer.appendChild(linkContainer);
      const actionsContainer = document.createElement("div");
      actionsContainer.className = "related-note-actions";
      const linkButton = document.createElement("button");
      linkButton.className = "related-note-link-button";
      linkButton.textContent = "Link";
      linkButton.title = "Add a link to this note";
      linkButton.addEventListener("click", async (e) => {
        e.stopPropagation();
        linkButton.disabled = true;
        linkButton.textContent = "Checking...";
        try {
          const hasLinkToRelated = await this.hasLink(file, relatedFile);
          if (hasLinkToRelated) {
            linkButton.textContent = "Linked";
            linkButton.classList.add("linked");
            linkButton.title = "This note is already linked";
          } else {
            await this.addLink(file, relatedFile);
            linkButton.textContent = "Linked";
            linkButton.classList.add("linked");
            linkButton.title = "Link added successfully";
          }
        } catch (error) {
          console.error("Error processing link:", error);
          linkButton.disabled = false;
          linkButton.textContent = "Link";
        }
      });
      actionsContainer.appendChild(linkButton);
      itemContainer.appendChild(actionsContainer);
      listItemEl.appendChild(itemContainer);
      return listItemEl;
    });
    listItems.forEach((item) => listEl.appendChild(item));
    const container = this.containerEl.children[1];
    container.empty();
    container.appendChild(fragment);
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  maxSuggestions: 5,
  debugMode: false,
  // Debug mode disabled by default
  customTitle: "Related Notes",
  enableSampling: true,
  // Internal settings with good defaults
  similarityThreshold: 0.15,
  // Lowered from 0.3 to find more matches
  batchSize: 5,
  // Smaller batch size for more responsive processing
  priorityIndexSize: 1e4,
  ngramSizes: [3],
  hashFunctions: [3],
  commonWordsThreshold: 0.5,
  maxStopwords: 200,
  sampleSizeThreshold: 5e3,
  // Only sample when more than 5000 files
  maxSampleSize: 1e3
  // Maximum number of documents to sample
};
var RelatedNotesSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.reindexButton = null;
    this.plugin = plugin;
  }
  /**
   * Estimates the false positive rate of a bloom filter
   * @param m Size of the filter in bits
   * @param k Number of hash functions
   * @param n Number of elements in the filter
   * @returns Estimated false positive rate (0-1)
   */
  estimateFalsePositiveRate(m, k, n) {
    const power = -k * n / m;
    const innerTerm = 1 - Math.exp(power);
    return Math.pow(innerTerm, k);
  }
  /**
   * Generate debug information without PII
   * @returns String containing debug information
   */
  generateDebugInfo() {
    var _a, _b;
    const vault = this.app.vault;
    const files = vault.getMarkdownFiles();
    const stats = (_b = (_a = this.plugin.similarityProvider) == null ? void 0 : _a.getStats) == null ? void 0 : _b.call(_a);
    const debugInfo = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      plugin: {
        version: this.plugin.manifest.version,
        initialized: this.plugin.isInitializationComplete(),
        reindexing: this.plugin.isReindexingInProgress()
      },
      vault: {
        totalMarkdownFiles: files.length,
        configDirExists: !!vault.configDir
      },
      settings: {
        maxSuggestions: this.plugin.settings.maxSuggestions,
        debugMode: this.plugin.settings.debugMode,
        similarityThreshold: this.plugin.settings.similarityThreshold,
        enableSampling: this.plugin.settings.enableSampling,
        sampleSizeThreshold: this.plugin.settings.sampleSizeThreshold,
        maxSampleSize: this.plugin.settings.maxSampleSize,
        ngramSizes: this.plugin.settings.ngramSizes,
        hashFunctions: this.plugin.settings.hashFunctions
      },
      system: {
        platform: navigator.platform,
        userAgent: navigator.userAgent,
        memoryAvailable: navigator.deviceMemory || "unknown",
        hardwareConcurrency: navigator.hardwareConcurrency || "unknown"
      },
      index: stats ? {
        documentsIndexed: stats.documentsProcessed || 0,
        progressiveIndexing: stats.progressiveIndexing,
        memoryUsage: stats.memoryUsage,
        avgProcessingTime: stats.averageProcessingTime
      } : null
    };
    return JSON.stringify(debugInfo, null, 2);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Related Notes Settings" });
    new import_obsidian2.Setting(containerEl).setName("Maximum suggestions").setDesc("Maximum number of related notes to display (1\u201320).").addSlider((slider) => slider.setLimits(1, 20, 1).setValue(this.plugin.settings.maxSuggestions).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxSuggestions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Custom title").setDesc('Customize the text displayed in place of "Related Notes".').addText((text) => text.setPlaceholder("Related Notes").setValue(this.plugin.settings.customTitle).onChange(async (value) => {
      this.plugin.settings.customTitle = value || "Related Notes";
      await this.plugin.saveSettings();
    }));
    const reindexSetting = new import_obsidian2.Setting(containerEl).setName("Rebuild index").setDesc("Update the index if related notes suggestions seem out of date.");
    const clearCacheSetting = new import_obsidian2.Setting(containerEl).setName("Clear cache").setDesc("Remove all cached data and start fresh. Use this if you encounter issues.");
    clearCacheSetting.addButton(
      (button) => button.setButtonText("Clear cache").setCta().onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Clearing...");
        try {
          await this.plugin.clearCache();
          new import_obsidian2.Notice("Cache cleared successfully");
        } catch (error) {
          console.error("Error clearing cache:", error);
          new import_obsidian2.Notice("Error clearing cache");
        } finally {
          button.setDisabled(false);
          button.setButtonText("Clear cache");
        }
      })
    );
    const buttonContainer = reindexSetting.controlEl.createDiv({ cls: "related-notes-button-container" });
    this.reindexButton = buttonContainer.createEl("button", {
      text: "Rebuild index",
      cls: "mod-cta"
    });
    if (this.plugin.isReindexingInProgress() || !this.plugin.isInitializationComplete()) {
      this.reindexButton.disabled = true;
      if (this.plugin.isReindexingInProgress()) {
        this.reindexButton.title = "Re-indexing is already in progress";
      } else if (!this.plugin.isInitializationComplete()) {
        this.reindexButton.title = "Initial indexing is still in progress";
      }
    }
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-warning"
    });
    if (this.plugin.isReindexingInProgress()) {
      cancelButton.addClass("related-notes-cancel-button-visible");
      cancelButton.removeClass("related-notes-cancel-button-hidden");
      this.reindexButton.disabled = true;
      this.reindexButton.setText("Re-indexing...");
      cancelButton.addEventListener("click", () => {
        this.plugin.cancelReindex();
        this.reindexButton.disabled = false;
        this.reindexButton.setText("Rebuild index");
        cancelButton.removeClass("related-notes-cancel-button-visible");
        cancelButton.addClass("related-notes-cancel-button-hidden");
      });
    } else {
      cancelButton.addClass("related-notes-cancel-button-hidden");
      cancelButton.removeClass("related-notes-cancel-button-visible");
    }
    this.reindexButton.addEventListener("click", async () => {
      this.reindexButton.disabled = true;
      this.reindexButton.setText("Re-indexing...");
      cancelButton.removeClass("related-notes-cancel-button-hidden");
      cancelButton.addClass("related-notes-cancel-button-visible");
      let cancelled = false;
      const cancelHandler = () => {
        cancelled = true;
        this.plugin.cancelReindex();
        this.reindexButton.disabled = false;
        this.reindexButton.setText("Rebuild index");
        cancelButton.removeClass("related-notes-cancel-button-visible");
        cancelButton.addClass("related-notes-cancel-button-hidden");
      };
      cancelButton.addEventListener("click", cancelHandler);
      try {
        await this.plugin.forceReindex();
      } catch (error) {
        if (!(error instanceof Error && error.message === "Indexing cancelled")) {
          console.error("Error during re-indexing:", error);
        }
      } finally {
        cancelButton.removeEventListener("click", cancelHandler);
        cancelButton.removeClass("related-notes-cancel-button-visible");
        cancelButton.addClass("related-notes-cancel-button-hidden");
        this.reindexButton.disabled = false;
        this.reindexButton.setText("Rebuild index");
      }
    });
    new import_obsidian2.Setting(containerEl).setName("Debug mode").setDesc("Enable debug logging to the console. Useful for troubleshooting but may impact performance.").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
      if (value) {
        new import_obsidian2.Notice("Debug mode enabled. Some debug messages will appear in the developer console.");
      } else {
        new import_obsidian2.Notice("Debug mode disabled.");
      }
    }));
    new import_obsidian2.Setting(containerEl).setName("Report a bug").setDesc("Open GitHub issues page to report bugs or request features").addButton((button) => button.setButtonText("Report a bug \u2197").setCta().onClick(() => {
      window.open("https://github.com/mrboxtobox/obsidian-related-notes/issues", "_blank");
    }));
    new import_obsidian2.Setting(containerEl).setName("Copy debug info").setDesc("Copy debug information to clipboard for bug reports.").addButton((button) => button.setButtonText("Copy debug info").setCta().onClick(async () => {
      try {
        const debugInfo = this.generateDebugInfo();
        await navigator.clipboard.writeText(debugInfo);
        new import_obsidian2.Notice("Debug info copied to clipboard! Please include this when reporting bugs.");
      } catch (error) {
        console.error("Failed to copy debug info:", error);
        new import_obsidian2.Notice("Failed to copy debug info. Please try again or check console for details.");
      }
    }));
    const supportEl = containerEl.createEl("div", { cls: "related-notes-support-section" });
    supportEl.createEl("p", {
      text: "If this plugin helps you discover meaningful connections in your notes, consider supporting its development:"
    });
    supportEl.innerHTML = '<div style="text-align: left;"><a href="https://www.buymeacoffee.com/mrboxtobox" target="_blank" rel="noopener noreferrer"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=mrboxtobox&button_colour=5F7FFF&font_colour=ffffff&font_family=Cookie&outline_colour=000000&coffee_colour=FFDD00" /></a></div>';
  }
};

// src/core.ts
function isValidUrlPattern(url) {
  if (url.length > 2e3 || url.length < 4)
    return false;
  let plusCount = 0;
  let starCount = 0;
  let dotCount = 0;
  let slashCount = 0;
  let questionCount = 0;
  let hashCount = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url[i];
    switch (char) {
      case "+":
        if (++plusCount > 10)
          return false;
        break;
      case "*":
        if (++starCount > 10)
          return false;
        break;
      case ".":
        if (++dotCount > 50)
          return false;
        break;
      case "/":
        if (++slashCount > 20)
          return false;
        break;
      case "?":
        if (++questionCount > 10)
          return false;
        break;
      case "#":
        if (++hashCount > 10)
          return false;
        break;
    }
  }
  if (url.startsWith("http://") || url.startsWith("https://")) {
    const protocolIndex = url.indexOf("://");
    if (protocolIndex === -1)
      return false;
    const afterProtocol = url.substring(protocolIndex + 3);
    return afterProtocol.length > 0 && afterProtocol.length < 1500;
  }
  if (url.startsWith("file://")) {
    const afterProtocol = url.substring(7);
    return afterProtocol.length > 0 && afterProtocol.length < 800;
  }
  const fileExtensions = ["md", "txt", "js", "ts", "html", "css", "json", "py", "java", "rb", "c", "cpp", "h", "go", "rs", "php"];
  const lowerUrl = url.toLowerCase();
  const hasValidExtension = fileExtensions.some((ext) => {
    const expectedSuffix = `.${ext}`;
    return lowerUrl.length >= expectedSuffix.length && lowerUrl.substring(lowerUrl.length - expectedSuffix.length) === expectedSuffix;
  });
  return hasValidExtension && url.length < 500;
}
function tokenize(text) {
  if (!text)
    return "";
  if (text.toLowerCase().includes("up up down down left right left right b a")) {
    console.log("\u{1F3AE} Konami code detected! You found the easter egg! \u{1F389}");
    console.log("\u2B50 Related Notes Plugin - Finding connections since 2024 \u2B50");
    console.log("\u2615 Powered by coffee and curiosity");
  }
  const stopWords = /* @__PURE__ */ new Set([
    // Articles
    "a",
    "an",
    "the",
    // Prepositions
    "in",
    "on",
    "at",
    "with",
    "by",
    "from",
    "to",
    "for",
    "of",
    "about",
    "as",
    "into",
    "over",
    "under",
    "above",
    "below",
    "between",
    "among",
    "through",
    // Conjunctions
    "and",
    "but",
    "or",
    "nor",
    "so",
    "yet",
    "after",
    "although",
    "because",
    // Common verbs
    "am",
    "is",
    "are",
    "was",
    "were",
    "be",
    "been",
    "being",
    "have",
    "has",
    "had",
    "do",
    "does",
    "did",
    "will",
    "would",
    "shall",
    "should",
    "can",
    "could",
    "may",
    "might",
    "must",
    // Pronouns
    "i",
    "me",
    "my",
    "mine",
    "myself",
    "you",
    "your",
    "yours",
    "yourself",
    "he",
    "him",
    "his",
    "himself",
    "she",
    "her",
    "hers",
    "herself",
    "it",
    "its",
    "itself",
    "we",
    "us",
    "our",
    "ours",
    "ourselves",
    "they",
    "them",
    "their",
    "theirs",
    "themselves",
    "this",
    "that",
    "these",
    "those",
    // Other common words
    "what",
    "which",
    "who",
    "whom",
    "whose",
    "when",
    "where",
    "why",
    "how",
    "all",
    "any",
    "both",
    "each",
    "few",
    "more",
    "most",
    "some",
    "no",
    "not",
    "only",
    "than",
    "too",
    "very"
  ]);
  const contractions = /* @__PURE__ */ new Map([
    // Negations
    ["n't", " not"],
    // Verb forms
    ["'re", " are"],
    ["'m", " am"],
    ["'s", " is"],
    ["'ve", " have"],
    ["'d", " would"],
    ["'ll", " will"],
    // Special cases
    ["'clock", " oclock"],
    ["o'clock", "oclock"],
    ["'cause", " because"],
    ["'n'", " and "],
    // Possessives - preserve the base word
    ["s'", "s"],
    ["s's", "s"]
  ]);
  try {
    const codeBlocks = [];
    let codeBlockCounter = 0;
    let processed = text.replace(/`([^`]+)`|```[\s\S]+?```/g, (match) => {
      const placeholder = `__code_block_${codeBlockCounter}__`;
      codeBlocks.push(match);
      codeBlockCounter++;
      return placeholder;
    });
    const urls = [];
    let urlCounter = 0;
    processed = processed.replace(/\S+/g, (match) => {
      if (match.length > 500)
        return match;
      if (match.startsWith("http://") || match.startsWith("https://") || match.startsWith("file://") || isValidUrlPattern(match)) {
        const placeholder = `__url_${urlCounter}__`;
        urls.push(match);
        urlCounter++;
        return placeholder;
      }
      return match;
    });
    processed = processed.replace(
      new RegExp(Object.keys(contractions).join("|"), "g"),
      (match) => contractions.get(match) || match
    );
    const hasCJK = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/.test(processed);
    let tokens = [];
    if (hasCJK) {
      processed = processed.normalize("NFC").toLowerCase();
      const cjkPattern = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]|[a-z0-9_\-]+/g;
      const matches = processed.match(cjkPattern) || [];
      tokens = matches.filter((term) => {
        if (/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/.test(term)) {
          return true;
        }
        return term.length > 2 && !stopWords.has(term);
      });
      const cjkChars = processed.match(/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/g) || [];
      for (let i = 0; i < cjkChars.length - 1; i++) {
        tokens.push(cjkChars[i] + cjkChars[i + 1]);
      }
    } else {
      processed = processed.toLowerCase().replace(/[^\w\s\-_]/g, " ").replace(/\s+/g, " ");
      tokens = processed.split(/\s+/).filter((word) => word.length > 2 && !stopWords.has(word));
      tokens = tokens.map((word) => {
        if (word.includes("/") || word.includes(".") || word.includes("_") || word.includes("-")) {
          return word;
        }
        if (word.endsWith("ing") && word.length > 5)
          return word.slice(0, -3);
        if (word.endsWith("ed") && word.length > 4)
          return word.slice(0, -2);
        if (word.endsWith("s") && !word.endsWith("ss") && word.length > 3)
          return word.slice(0, -1);
        if (word.endsWith("es") && word.length > 4)
          return word.slice(0, -2);
        if (word.endsWith("ies") && word.length > 5)
          return word.slice(0, -3) + "y";
        if (word.endsWith("ly") && word.length > 4)
          return word.slice(0, -2);
        return word;
      });
    }
    tokens = tokens.map((token) => {
      if (token.startsWith("__code_block_")) {
        const index = parseInt(token.replace("__code_block_", "").replace("__", ""));
        return codeBlocks[index] ? codeBlocks[index].replace(/`|```/g, "").trim() : token;
      }
      if (token.startsWith("__url_")) {
        const index = parseInt(token.replace("__url_", "").replace("__", ""));
        return urls[index] || token;
      }
      return token;
    });
    return tokens.join(" ");
  } catch (error) {
    console.error("Error during tokenization:", error);
    return "";
  }
}

// src/logging.ts
var globalDebugMode = false;
function setDebugMode(enabled) {
  globalDebugMode = enabled;
}
function isDebugMode() {
  return globalDebugMode;
}
function logIfDebugModeEnabled(message, ...data) {
  if (globalDebugMode) {
    console.log(`[RelatedNotes Debug] ${message}`, ...data);
  }
}
function logPerformance(message, ...data) {
  console.info(`[RelatedNotes Performance] ${message}`, ...data);
}

// src/bloom.ts
var BloomFilter = class {
  // Limit tracked items to prevent memory leak
  /**
   * Creates a new bloom filter
   * @param size Size of the bloom filter in bits (default: 256 bits)
   * @param hashFunctions Number of hash functions to use (default: 3)
   */
  constructor(size = 256, hashFunctions = 3) {
    this.addedItems = /* @__PURE__ */ new Set();
    // Track added items for debugging
    this.maxTrackedItems = 1e4;
    this.size = Math.ceil(size / 32) * 32;
    this.bitArray = new Uint32Array(this.size / 32);
    this.hashFunctions = hashFunctions;
    logIfDebugModeEnabled(`Created bloom filter with ${this.size} bits and ${hashFunctions} hash functions`);
    logIfDebugModeEnabled(`Memory usage: ${this.size / 8} bytes (${this.size / 8 / 1024} KB)`);
  }
  /**
   * Gets the actual size of the bloom filter in bits
   */
  getSize() {
    return this.size;
  }
  /**
   * Gets the number of hash functions
   */
  getHashFunctions() {
    return this.hashFunctions;
  }
  /**
   * Gets the memory usage in bytes
   */
  getMemoryUsage() {
    return this.size / 8;
  }
  /**
   * Gets the estimated false positive rate based on current usage
   */
  getFalsePositiveRate() {
    const m = this.size;
    const k = this.hashFunctions;
    const n = this.addedItems.size;
    const power = -k * n / m;
    const innerTerm = 1 - Math.exp(power);
    return Math.pow(innerTerm, k);
  }
  /**
   * Adds an item to the bloom filter
   * @param item The item to add
   */
  add(item) {
    if (this.addedItems.size < this.maxTrackedItems) {
      this.addedItems.add(item);
    } else if (this.addedItems.size === this.maxTrackedItems && isDebugMode()) {
      logIfDebugModeEnabled(`BloomFilter: Stopped tracking items to prevent memory leak (max: ${this.maxTrackedItems})`);
    }
    const hashes = this.getHashes(item);
    if (isDebugMode() && item.length < 10) {
      logIfDebugModeEnabled(`Adding item: "${item}" with hashes:`, hashes.map((h) => h % this.size));
    }
    for (const hash of hashes) {
      const bitIndex = hash % this.size;
      const arrayIndex = Math.floor(bitIndex / 32);
      const bitOffset = bitIndex % 32;
      this.bitArray[arrayIndex] |= 1 << bitOffset;
    }
  }
  /**
   * Checks if an item might be in the bloom filter
   * @param item The item to check
   * @returns True if the item might be in the filter, false if it definitely isn't
   */
  contains(item) {
    const hashes = this.getHashes(item);
    for (const hash of hashes) {
      const bitIndex = hash % this.size;
      const arrayIndex = Math.floor(bitIndex / 32);
      const bitOffset = bitIndex % 32;
      if (!(this.bitArray[arrayIndex] & 1 << bitOffset)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Gets the raw bit array for similarity comparison
   */
  getBitArray() {
    return this.bitArray;
  }
  /**
   * Sets the bit array directly (used for deserialization)
   * @param array The bit array to set
   */
  setBitArray(array) {
    if (array.length === this.bitArray.length) {
      this.bitArray = array;
    } else {
      throw new Error(`Array length mismatch: got ${array.length}, expected ${this.bitArray.length}`);
    }
  }
  /**
   * Generates hash values for an item
   * @param item The item to hash
   * @returns Array of hash values
   */
  getHashes(item) {
    const hashes = [];
    const fnv1a = (str) => {
      let hash = 2166136261;
      for (let i = 0; i < str.length; i++) {
        hash ^= str.charCodeAt(i);
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      }
      return hash >>> 0;
    };
    const djb2 = (str) => {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) + hash + str.charCodeAt(i);
      }
      return hash >>> 0;
    };
    const sdbm = (str) => {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;
      }
      return hash >>> 0;
    };
    const baseHash = fnv1a(item);
    hashes.push(baseHash);
    if (this.hashFunctions > 1)
      hashes.push(djb2(item));
    if (this.hashFunctions > 2)
      hashes.push(sdbm(item));
    for (let i = 3; i < this.hashFunctions; i++) {
      hashes.push(hashes[0] + i * hashes[1] >>> 0);
    }
    return hashes;
  }
  /**
   * Serialize the bloom filter to a JSON-compatible object
   * @returns Serialized bloom filter data
   */
  serialize() {
    return {
      size: this.size,
      hashFunctions: this.hashFunctions,
      bitArray: Array.from(this.bitArray)
    };
  }
  /**
   * Deserialize and restore bloom filter from serialized data
   * @param data Serialized bloom filter data
   */
  deserialize(data) {
    if (data.size !== this.size || data.hashFunctions !== this.hashFunctions) {
      throw new Error(`Cannot deserialize: size/hash mismatch. Expected ${this.size}/${this.hashFunctions}, got ${data.size}/${data.hashFunctions}`);
    }
    this.bitArray = new Uint32Array(data.bitArray);
    this.addedItems.clear();
  }
  /**
   * Clear the bloom filter and reset all tracking data
   */
  clear() {
    this.bitArray.fill(0);
    this.addedItems.clear();
  }
  /**
   * Calculate Jaccard similarity between two bloom filters
   * @param other The other bloom filter to compare with
   * @returns Similarity score between 0 and 1
   */
  similarity(other) {
    if (this.size !== other.size) {
      logIfDebugModeEnabled(`Cannot directly compare bloom filters of different sizes: ${this.size} vs ${other.size}`);
      return 0;
    }
    let intersectionBits = 0;
    let unionBits = 0;
    let thisBits = 0;
    let otherBits = 0;
    for (let i = 0; i < this.bitArray.length; i++) {
      const intersection = this.bitArray[i] & other.bitArray[i];
      const union = this.bitArray[i] | other.bitArray[i];
      const thisCount = countBits(this.bitArray[i]);
      const otherCount = countBits(other.bitArray[i]);
      intersectionBits += countBits(intersection);
      unionBits += countBits(union);
      thisBits += thisCount;
      otherBits += otherCount;
    }
    const minBitsRequired = 5;
    if (thisBits < minBitsRequired || otherBits < minBitsRequired) {
      logIfDebugModeEnabled(`One or both documents too small for meaningful comparison: ${thisBits} vs ${otherBits} bits set`);
      return 0;
    }
    let similarity = unionBits === 0 ? 0 : intersectionBits / unionBits;
    const thisRatio = thisBits / this.size;
    const otherRatio = otherBits / this.size;
    if (thisRatio > 0.4 || otherRatio > 0.4) {
      const saturationFactor = Math.max(thisRatio, otherRatio);
      similarity = similarity * Math.pow(1 - saturationFactor, 2);
    }
    const rawSimilarity = unionBits === 0 ? 0 : intersectionBits / unionBits;
    logIfDebugModeEnabled(
      `Similarity details:
      - Filter 1: ${thisBits} bits set (${(thisRatio * 100).toFixed(1)}% of capacity)
      - Filter 2: ${otherBits} bits set (${(otherRatio * 100).toFixed(1)}% of capacity)
      - Intersection: ${intersectionBits} bits
      - Union: ${unionBits} bits
      - Items in filter 1: ${this.addedItems.size}
      - Items in filter 2: ${other.addedItems.size}
      - Raw similarity: ${(rawSimilarity * 100).toFixed(2)}%`
    );
    return similarity;
  }
  /**
   * Fast intersection count for candidate selection
   * @param other The other bloom filter to compare with
   * @returns Number of intersecting bits (higher = more similar)
   */
  intersectionCount(other) {
    if (this.size !== other.size) {
      return 0;
    }
    let intersectionBits = 0;
    for (let i = 0; i < this.bitArray.length; i++) {
      intersectionBits += countBits(this.bitArray[i] & other.bitArray[i]);
    }
    return intersectionBits;
  }
};
function countBits(n) {
  n = n - (n >> 1 & 1431655765);
  n = (n & 858993459) + (n >> 2 & 858993459);
  return (n + (n >> 4) & 252645135) * 16843009 >> 24;
}

// src/constants.ts
var TEXT_PROCESSING = {
  /** Maximum character limit for processing large documents */
  LARGE_DOCUMENT_LIMIT: 1e4,
  /** Maximum character limit for large vaults (lower fidelity) */
  LARGE_VAULT_DOCUMENT_LIMIT: 5e3,
  /** Minimum number of bits required for meaningful comparison */
  MIN_BITS_FOR_COMPARISON: 5,
  /** Character truncation fallback percentage */
  TRUNCATION_FALLBACK_RATIO: 0.9,
  /** Sentence boundary truncation ratio */
  SENTENCE_BOUNDARY_RATIO: 0.8,
  /** Word boundary truncation ratio */
  WORD_BOUNDARY_RATIO: 0.9
};
var BLOOM_FILTER = {
  /** Maximum bigrams for CJK text */
  MAX_BIGRAMS_CJK: 100,
  /** Maximum bigrams for non-CJK text */
  MAX_BIGRAMS_NON_CJK: 200,
  /** Maximum bigrams for CJK text (large vaults) */
  MAX_BIGRAMS_CJK_LARGE: 50,
  /** Maximum bigrams for non-CJK text (large vaults) */
  MAX_BIGRAMS_NON_CJK_LARGE: 100,
  /** Default fixed bloom filter size */
  DEFAULT_FILTER_SIZE: 8192,
  /** Lower fidelity bloom filter size for large vaults */
  LARGE_VAULT_FILTER_SIZE: 4096,
  /** Parameter update interval for adaptive parameters */
  PARAMETER_UPDATE_INTERVAL: 50,
  /** Bloom filter saturation threshold for similarity scaling */
  SATURATION_THRESHOLD: 0.4
};
var BATCH_PROCESSING = {
  /** Files per batch for progressive indexing */
  FILES_PER_BATCH: 50,
  /** Minutes between progressive indexing batches */
  PROGRESSIVE_INTERVAL_MINUTES: 10,
  /** Milliseconds between file processing batches */
  PROCESS_INTERVAL_MS: 2e3,
  /** Small batch size for UI responsiveness */
  SMALL_BATCH_SIZE: 3,
  /** Maximum initial index size */
  MAX_INITIAL_INDEX_SIZE: 1e3,
  /** Percentage of vault for initial indexing */
  INITIAL_INDEX_PERCENTAGE: 0.1
};
var WORD_FILTERING = {
  /** Maximum number of adaptive stopwords */
  MAX_STOPWORDS: 250,
  /** Threshold for common word detection */
  COMMON_WORDS_THRESHOLD: 0.5,
  /** Large vault threshold for sampling */
  LARGE_VAULT_THRESHOLD: 5e3,
  /** Word index threshold - use word-based candidate selection above this size */
  WORD_INDEX_THRESHOLD: 750,
  /** Maximum sample size for large vaults */
  MAX_SAMPLE_SIZE: 1e3
};
var MEMORY_LIMITS = {
  /** Maximum documents to process before forced cleanup */
  MAX_DOCUMENTS_BEFORE_CLEANUP: 1e4,
  /** Maximum memory usage estimate (MB) before cleanup */
  MAX_MEMORY_MB: 256,
  /** Maximum cache file size (MB) */
  MAX_CACHE_SIZE_MB: 50,
  /** Maximum single document size to process (MB) */
  MAX_DOCUMENT_SIZE_MB: 10
};
var TIMING = {
  /** Yield duration for async processing (ms) - generous to prevent blocking */
  YIELD_DURATION_MS: 16,
  // ~60fps frame budget
  /** Extended yield duration for heavy operations (ms) */
  EXTENDED_YIELD_DURATION_MS: 50,
  /** CPU throttling: max operations before mandatory yield */
  MAX_OPERATIONS_BEFORE_YIELD: 10,
  /** CPU throttling: minimum yield time during intensive operations */
  MIN_YIELD_TIME_MS: 16,
  /** Cache age threshold (30 days in milliseconds) */
  CACHE_AGE_THRESHOLD_MS: 30 * 24 * 60 * 60 * 1e3,
  /** Milliseconds in one minute */
  MS_PER_MINUTE: 60 * 1e3
};
var FILE_OPERATIONS = {
  /** Maximum retry attempts for file operations */
  MAX_RETRIES: 3,
  /** Base timeout for file operations (ms) - increased for slow systems */
  TIMEOUT_MS: 15e3,
  /** File read timeout (ms) - adaptive based on file size */
  READ_TIMEOUT_MS: 15e3,
  /** Cache operation timeout (ms) - longer for complex cache writes */
  CACHE_TIMEOUT_MS: 2e4,
  /** Base backoff delay (ms) */
  BASE_BACKOFF_MS: 1e3,
  /** Maximum backoff delay (ms) */
  MAX_BACKOFF_MS: 8e3,
  /** Timeout multiplier for large files (>1MB) */
  LARGE_FILE_TIMEOUT_MULTIPLIER: 2
};
var WORD_INDEX = {
  /** Default number of random words to sample for candidate selection */
  DEFAULT_SAMPLE_WORDS: 4,
  /** Maximum number of random words to sample */
  MAX_SAMPLE_WORDS: 8,
  /** Minimum number of random words to sample */
  MIN_SAMPLE_WORDS: 2,
  /** Default maximum candidates from word sampling */
  DEFAULT_MAX_CANDIDATES: 100,
  /** Threshold for document frequency filtering (words appearing in >70% docs are too common) */
  DOCUMENT_FREQUENCY_THRESHOLD: 0.7,
  /** Minimum document count for rare word filtering in large corpora */
  MIN_DOCUMENT_COUNT_LARGE_CORPUS: 2
};
var CACHE = {
  /** Current cache version */
  VERSION: 1,
  /** Cache directory relative path */
  RELATIVE_PATH: "/plugins/obsidian-related-notes/",
  /** Cache file name */
  FILENAME: ".bloom-filter-cache.json",
  /** In-memory similarity cache TTL (5 minutes in milliseconds) */
  SIMILARITY_TTL_MS: 5 * 60 * 1e3,
  /** Maximum in-memory cache entries before cleanup */
  MAX_MEMORY_CACHE_ENTRIES: 1e3,
  /** Memory cache cleanup threshold (remove entries when cache exceeds this) */
  MEMORY_CACHE_CLEANUP_THRESHOLD: 800
};

// src/word-index.ts
var WordBasedCandidateSelector = class {
  constructor() {
    // Global word index: word -> Set of document paths containing that word
    this.wordIndex = /* @__PURE__ */ new Map();
    // Document word cache: document path -> Set of words in that document
    this.documentWords = /* @__PURE__ */ new Map();
    // Statistics
    this.totalDocuments = 0;
    this.totalWords = 0;
  }
  /**
   * Add a document to the word index
   * @param docPath Document path
   * @param text Document content
   */
  addDocument(docPath, text) {
    this.removeDocument(docPath);
    const processed = tokenize(text);
    const words = this.extractMeaningfulWords(processed);
    this.documentWords.set(docPath, words);
    for (const word of words) {
      if (!this.wordIndex.has(word)) {
        this.wordIndex.set(word, /* @__PURE__ */ new Set());
      }
      this.wordIndex.get(word).add(docPath);
    }
    this.totalDocuments++;
    this.totalWords += words.size;
    logIfDebugModeEnabled(`Added document ${docPath} with ${words.size} unique words to word index`);
  }
  /**
   * Remove a document from the word index
   * @param docPath Document path to remove
   */
  removeDocument(docPath) {
    const words = this.documentWords.get(docPath);
    if (!words)
      return;
    for (const word of words) {
      const docsWithWord = this.wordIndex.get(word);
      if (docsWithWord) {
        docsWithWord.delete(docPath);
        if (docsWithWord.size === 0) {
          this.wordIndex.delete(word);
        }
      }
    }
    this.documentWords.delete(docPath);
    this.totalDocuments = Math.max(0, this.totalDocuments - 1);
    logIfDebugModeEnabled(`Removed document ${docPath} from word index`);
  }
  /**
   * Get fast candidates using random word sampling
   * @param queryDocPath Path of query document
   * @param maxCandidates Maximum number of candidates to return
   * @param numSampleWords Number of random words to sample (default from constants)
   * @returns Array of candidate document paths
   */
  getFastCandidates(queryDocPath, maxCandidates = WORD_INDEX.DEFAULT_MAX_CANDIDATES, numSampleWords = WORD_INDEX.DEFAULT_SAMPLE_WORDS) {
    const queryWords = this.documentWords.get(queryDocPath);
    if (!queryWords || queryWords.size === 0) {
      logIfDebugModeEnabled(`No words found for query document ${queryDocPath}`);
      return [];
    }
    const candidates = /* @__PURE__ */ new Map();
    const wordsArray = Array.from(queryWords);
    const sampleWords = this.sampleRandomWords(wordsArray, numSampleWords);
    if (sampleWords.length === 0) {
      logIfDebugModeEnabled(`No sample words available for ${queryDocPath}`);
      return [];
    }
    logIfDebugModeEnabled(`Sampling ${sampleWords.length} words for fast candidate selection: ${sampleWords.join(", ")}`);
    for (const word of sampleWords) {
      const docsWithWord = this.wordIndex.get(word);
      if (docsWithWord) {
        for (const docPath of docsWithWord) {
          if (docPath !== queryDocPath) {
            const currentScore = candidates.get(docPath) || 0;
            candidates.set(docPath, currentScore + 1);
          }
        }
      }
    }
    const sortedCandidates = Array.from(candidates.entries()).sort((a, b) => b[1] - a[1]).slice(0, maxCandidates).map(([docPath]) => docPath);
    logIfDebugModeEnabled(`Found ${sortedCandidates.length} fast candidates for ${queryDocPath} using word sampling`);
    return sortedCandidates;
  }
  /**
   * Get candidates that share specific words with the query
   * @param queryDocPath Path of query document
   * @param specificWords Array of specific words to search for
   * @param maxCandidates Maximum candidates to return
   * @returns Array of candidate document paths
   */
  getCandidatesForWords(queryDocPath, specificWords, maxCandidates = 100) {
    const candidates = /* @__PURE__ */ new Set();
    for (const word of specificWords) {
      const docsWithWord = this.wordIndex.get(word);
      if (docsWithWord) {
        for (const docPath of docsWithWord) {
          if (docPath !== queryDocPath && candidates.size < maxCandidates) {
            candidates.add(docPath);
          }
        }
      }
    }
    return Array.from(candidates);
  }
  /**
   * Get the most common words in the corpus
   * @param limit Number of words to return
   * @returns Array of [word, documentCount] pairs
   */
  getMostCommonWords(limit = 50) {
    const wordCounts = Array.from(this.wordIndex.entries()).map(([word, docs]) => [word, docs.size]).sort((a, b) => b[1] - a[1]).slice(0, limit);
    return wordCounts;
  }
  /**
   * Extract meaningful words from processed text
   * Filters out very common and very rare words
   * @param processed Tokenized text
   * @returns Set of meaningful words
   */
  extractMeaningfulWords(processed) {
    var _a;
    const words = processed.toLowerCase().split(/\s+/);
    const meaningfulWords = /* @__PURE__ */ new Set();
    for (const word of words) {
      if (word.length < 3)
        continue;
      if (word.length > 20)
        continue;
      if ((word.match(/[^a-z0-9]/g) || []).length > word.length * 0.3)
        continue;
      if (/^\d+$/.test(word) && word.length < 4)
        continue;
      meaningfulWords.add(word);
    }
    if (this.totalDocuments < 10) {
      return meaningfulWords;
    }
    const filtered = /* @__PURE__ */ new Set();
    for (const word of meaningfulWords) {
      const docCount = ((_a = this.wordIndex.get(word)) == null ? void 0 : _a.size) || 0;
      const documentRatio = this.totalDocuments > 0 ? docCount / this.totalDocuments : 0;
      if (documentRatio > WORD_INDEX.DOCUMENT_FREQUENCY_THRESHOLD)
        continue;
      if (this.totalDocuments > 100 && docCount < WORD_INDEX.MIN_DOCUMENT_COUNT_LARGE_CORPUS)
        continue;
      filtered.add(word);
    }
    return filtered.size > 0 ? filtered : meaningfulWords;
  }
  /**
   * Sample random words from an array
   * @param words Array of words to sample from
   * @param numSamples Number of samples to take
   * @returns Array of sampled words
   */
  sampleRandomWords(words, numSamples) {
    if (words.length <= numSamples) {
      return [...words];
    }
    const sampled = [];
    const used = /* @__PURE__ */ new Set();
    while (sampled.length < numSamples && used.size < words.length) {
      const randomIndex = Math.floor(Math.random() * words.length);
      if (!used.has(randomIndex)) {
        used.add(randomIndex);
        sampled.push(words[randomIndex]);
      }
    }
    return sampled;
  }
  /**
   * Clear the entire index
   */
  clear() {
    this.wordIndex.clear();
    this.documentWords.clear();
    this.totalDocuments = 0;
    this.totalWords = 0;
    logIfDebugModeEnabled("Cleared word-based candidate selector");
  }
  /**
   * Get statistics about the word index
   */
  getStats() {
    return {
      totalDocuments: this.totalDocuments,
      totalUniqueWords: this.wordIndex.size,
      totalWordOccurrences: this.totalWords,
      averageWordsPerDocument: this.totalDocuments > 0 ? this.totalWords / this.totalDocuments : 0,
      averageDocumentsPerWord: this.wordIndex.size > 0 ? Array.from(this.wordIndex.values()).reduce((sum, docs) => sum + docs.size, 0) / this.wordIndex.size : 0
    };
  }
  /**
   * Check if a document is indexed
   * @param docPath Document path
   * @returns True if document is in the index
   */
  isDocumentIndexed(docPath) {
    return this.documentWords.has(docPath);
  }
  /**
   * Get all documents that contain a specific word
   * @param word Word to search for
   * @returns Array of document paths containing the word
   */
  getDocumentsContainingWord(word) {
    const docs = this.wordIndex.get(word.toLowerCase());
    return docs ? Array.from(docs) : [];
  }
};

// src/multi-bloom.ts
var import_obsidian3 = require("obsidian");

// src/error-handling.ts
var _ErrorHandler = class _ErrorHandler {
  constructor(config = {}) {
    this.errorCount = /* @__PURE__ */ new Map();
    this.config = {
      logToConsole: true,
      includeStackTrace: true,
      maxContextSize: 1e3,
      ...config
    };
  }
  /**
   * Get the singleton instance of ErrorHandler
   */
  static getInstance(config) {
    if (!_ErrorHandler.instance) {
      _ErrorHandler.instance = new _ErrorHandler(config);
    }
    return _ErrorHandler.instance;
  }
  /**
   * Handle an error with structured logging
   */
  handleError(errorInfo) {
    if (!errorInfo.timestamp) {
      errorInfo.timestamp = Date.now();
    }
    const currentCount = this.errorCount.get(errorInfo.category) || 0;
    this.errorCount.set(errorInfo.category, currentCount + 1);
    this.logError(errorInfo);
    if (errorInfo.severity === "critical" /* CRITICAL */) {
      console.error(`[RelatedNotes CRITICAL] ${errorInfo.message}`, errorInfo.originalError);
    }
  }
  /**
   * Log the error based on configuration and debug mode
   */
  logError(errorInfo) {
    var _a;
    if (!this.config.logToConsole && !isDebugMode()) {
      return;
    }
    const prefix = `[RelatedNotes:${errorInfo.category}:${errorInfo.severity}]`;
    const timestamp = new Date(errorInfo.timestamp).toISOString();
    let logMessage = `${prefix} ${timestamp} - ${errorInfo.message}`;
    if (errorInfo.context) {
      const contextStr = JSON.stringify(errorInfo.context);
      if (contextStr.length <= this.config.maxContextSize) {
        logMessage += ` | Context: ${contextStr}`;
      } else {
        logMessage += ` | Context: [Too large to display - ${contextStr.length} chars]`;
      }
    }
    switch (errorInfo.severity) {
      case "critical" /* CRITICAL */:
        console.error(logMessage, errorInfo.originalError);
        break;
      case "high" /* HIGH */:
        console.error(logMessage, errorInfo.originalError);
        break;
      case "medium" /* MEDIUM */:
        console.warn(logMessage, errorInfo.originalError);
        break;
      case "low" /* LOW */:
        if (isDebugMode()) {
          console.info(logMessage, errorInfo.originalError);
        }
        break;
    }
    if (this.config.includeStackTrace && ((_a = errorInfo.originalError) == null ? void 0 : _a.stack)) {
      console.group("Stack trace:");
      console.info(errorInfo.originalError.stack);
      console.groupEnd();
    }
  }
  /**
   * Get error statistics
   */
  getErrorStats() {
    const stats = {};
    for (const [category, count] of this.errorCount.entries()) {
      stats[category] = count;
    }
    return stats;
  }
  /**
   * Reset error statistics
   */
  resetStats() {
    this.errorCount.clear();
  }
  /**
   * Update configuration
   */
  updateConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }
};
_ErrorHandler.instance = null;
var ErrorHandler = _ErrorHandler;
function handleFileError(error, operation, filePath) {
  ErrorHandler.getInstance().handleError({
    message: `File operation failed: ${operation}`,
    category: "file_operation" /* FILE_OPERATION */,
    severity: "medium" /* MEDIUM */,
    context: { operation, filePath },
    originalError: error
  });
}
function handleCacheError(error, operation, details) {
  ErrorHandler.getInstance().handleError({
    message: `Cache operation failed: ${operation}`,
    category: "cache_operation" /* CACHE_OPERATION */,
    severity: "medium" /* MEDIUM */,
    context: { operation, ...details },
    originalError: error
  });
}
function handleIndexingError(error, documentId, details) {
  ErrorHandler.getInstance().handleError({
    message: `Indexing operation failed`,
    category: "indexing" /* INDEXING */,
    severity: "high" /* HIGH */,
    context: { documentId, ...details },
    originalError: error
  });
}
function handleUIError(error, component, action) {
  ErrorHandler.getInstance().handleError({
    message: `UI operation failed`,
    category: "ui" /* UI */,
    severity: "low" /* LOW */,
    context: { component, action },
    originalError: error
  });
}
function handleValidationError(error, validationType, value) {
  ErrorHandler.getInstance().handleError({
    message: `Validation failed`,
    category: "validation" /* VALIDATION */,
    severity: "medium" /* MEDIUM */,
    context: { validationType, value: typeof value === "string" ? value.substring(0, 100) : value },
    originalError: error
  });
}

// src/multi-bloom.ts
function calculateOptimalHashFunctions(size, itemCount) {
  return Math.max(1, Math.round(size / itemCount * Math.log(2)));
}
var SingleBloomFilter = class {
  /**
   * Creates a new bloom filter
   * @param ngramSizes Array of n-gram sizes (only first value is used, kept for backward compatibility)
   * @param bloomSizes Array of bloom filter sizes (only first value is used)
   * @param hashFunctions Array of hash function counts (only first value is used)
   */
  constructor(ngramSizes = [3], bloomSizes, hashFunctions) {
    // Statistics
    this.addedItems = /* @__PURE__ */ new Set();
    this.itemCount = 0;
    this.filters = {
      get: (ngramSize) => ngramSize === this.ngramSizes[0] ? this.filter : void 0
    };
    this.ngramSizes = ngramSizes;
    this.bloomSize = bloomSizes && bloomSizes.length > 0 ? bloomSizes[0] : BLOOM_FILTER.LARGE_VAULT_FILTER_SIZE;
    this.hashFunctionCount = hashFunctions && hashFunctions.length > 0 ? hashFunctions[0] : 3;
    this.filter = new BloomFilter(this.bloomSize, this.hashFunctionCount);
  }
  /**
   * Add text to the bloom filter
   * @param text The text to add
   */
  addText(text) {
    this.addedItems.add(text);
    const words = this.extractWords(text);
    for (const word of words) {
      this.filter.add(word);
      this.itemCount++;
    }
    if (isDebugMode()) {
    }
  }
  /**
   * Calculate similarity between this filter and another
   * @param other The other filter
   * @returns Similarity score between 0 and 1
   */
  similarity(other) {
    try {
      return this.filter.similarity(other.filter);
    } catch (error) {
      console.error("Error comparing filters:", error);
      return 0;
    }
  }
  /**
   * Fast intersection count estimate for candidate selection
   * @param other The other filter
   * @returns Approximate intersection count (higher = more similar)
   */
  fastIntersectionCount(other) {
    try {
      return this.filter.intersectionCount(other.filter);
    } catch (error) {
      console.error("Error calculating fast intersection:", error);
      return 0;
    }
  }
  /**
   * Extract words from text, with special handling for CJK scripts
   * @param text Input text
   * @returns Set of words and word pairs
   */
  extractWords(text) {
    const processed = tokenize(text);
    const words = processed.split(/\s+/);
    const wordSet = new Set(words);
    const hasCJK = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/.test(text);
    const isLowFidelity = wordSet.size > 500;
    const maxBigrams = isLowFidelity ? hasCJK ? BLOOM_FILTER.MAX_BIGRAMS_CJK_LARGE : BLOOM_FILTER.MAX_BIGRAMS_NON_CJK_LARGE : hasCJK ? BLOOM_FILTER.MAX_BIGRAMS_CJK : BLOOM_FILTER.MAX_BIGRAMS_NON_CJK;
    let count = 0;
    for (let i = 0; i < words.length - 1 && count < maxBigrams; i++) {
      const bigram = `${words[i]} ${words[i + 1]}`;
      wordSet.add(bigram);
      count++;
    }
    return wordSet;
  }
  /**
   * Get statistics about the bloom filter
   */
  getStats() {
    return {
      type: "simplified",
      bloomSize: this.bloomSize,
      hashFunctionCount: this.hashFunctionCount,
      itemCount: this.itemCount,
      totalMemoryBytes: this.bloomSize / 8,
      saturation: this.filter.getFalsePositiveRate(),
      addedItems: this.addedItems.size
    };
  }
  /**
   * These methods are kept for backward compatibility
   */
  getBitArray() {
    return this.filter.getBitArray();
  }
  getSize() {
    return this.bloomSize;
  }
  getHashFunctions() {
    return this.hashFunctionCount;
  }
  getFalsePositiveRate() {
    return this.filter.getFalsePositiveRate();
  }
};
var AdaptiveParameterCalculator = class {
  constructor() {
    this.documentLengths = [];
    this.vocabularySizes = [];
    this.averageDocLength = 0;
    this.averageVocabularySize = 0;
    this.documentsAnalyzed = 0;
  }
  /**
   * Track document statistics to inform parameter decisions
   * @param text Document text
   */
  analyzeDocument(text) {
    const processed = tokenize(text);
    const words = processed.toLowerCase().split(/\s+/);
    const uniqueWords = new Set(words);
    this.documentLengths.push(words.length);
    this.vocabularySizes.push(uniqueWords.size);
    this.documentsAnalyzed++;
    this.averageDocLength = this.documentLengths.reduce((sum, len) => sum + len, 0) / this.documentsAnalyzed;
    this.averageVocabularySize = this.vocabularySizes.reduce((sum, size) => sum + size, 0) / this.documentsAnalyzed;
  }
  /**
   * Calculate optimal n-gram sizes based on document characteristics
   * @returns Array of recommended n-gram sizes
   */
  calculateOptimalNgramSizes() {
    return [3];
  }
  /**
   * Calculate optimal bloom filter sizes based on vocabulary size
   * @param ngramSizes Array of n-gram sizes
   * @param falsePositiveRate Desired false positive rate (default: 0.01)
   * @returns Array of recommended bloom filter sizes
   */
  calculateOptimalBloomSizes(ngramSizes, falsePositiveRate = 0.01) {
    const isLargeCorpus = this.documentsAnalyzed > WORD_FILTERING.LARGE_VAULT_THRESHOLD;
    const fixedSize = isLargeCorpus ? BLOOM_FILTER.LARGE_VAULT_FILTER_SIZE : BLOOM_FILTER.DEFAULT_FILTER_SIZE;
    return ngramSizes.map(() => fixedSize);
  }
  /**
   * Calculate optimal hash function counts
   * @param bloomSizes Array of bloom filter sizes
   * @param ngramSizes Array of n-gram sizes
   * @returns Array of recommended hash function counts
   */
  calculateOptimalHashFunctions(bloomSizes, ngramSizes) {
    return bloomSizes.map((size, i) => {
      const ngramSize = ngramSizes[i];
      const estimatedNgrams = Math.ceil(this.averageVocabularySize * Math.pow(1.5, ngramSize - 1));
      return calculateOptimalHashFunctions(size, estimatedNgrams);
    });
  }
  /**
   * Calculate optimal similarity threshold based on corpus characteristics
   * @returns Recommended similarity threshold (0-1)
   */
  calculateOptimalSimilarityThreshold() {
    return 0.15;
  }
  /**
   * Get statistics about analyzed documents
   */
  getStats() {
    return {
      documentsAnalyzed: this.documentsAnalyzed,
      averageDocLength: this.averageDocLength,
      averageVocabularySize: this.averageVocabularySize,
      minDocLength: Math.min(...this.documentLengths),
      maxDocLength: Math.max(...this.documentLengths),
      minVocabularySize: Math.min(...this.vocabularySizes),
      maxVocabularySize: Math.max(...this.vocabularySizes)
    };
  }
  /**
   * Generate a complete set of recommended parameters
   * @param falsePositiveRate Desired false positive rate
   * @returns Object containing all recommended parameters
   */
  generateRecommendedParameters(falsePositiveRate = 0.01) {
    const ngramSizes = this.calculateOptimalNgramSizes();
    const bloomSizes = this.calculateOptimalBloomSizes(ngramSizes, falsePositiveRate);
    const hashFunctions = this.calculateOptimalHashFunctions(bloomSizes, ngramSizes);
    const similarityThreshold = this.calculateOptimalSimilarityThreshold();
    return {
      ngramSizes,
      bloomSizes,
      hashFunctions,
      similarityThreshold
    };
  }
};
var MultiResolutionBloomFilterProvider = class {
  constructor(vault, config = {}) {
    this.bloomFilters = /* @__PURE__ */ new Map();
    this.documentNgrams = /* @__PURE__ */ new Map();
    this.parameterCalculator = new AdaptiveParameterCalculator();
    this.wordCandidateSelector = new WordBasedCandidateSelector();
    this.adaptiveParameters = false;
    this.parameterUpdateInterval = BLOOM_FILTER.PARAMETER_UPDATE_INTERVAL;
    // Reduced from 100 to 50 for faster parameter adaptation
    this.documentsProcessed = 0;
    this.onProgressCallback = null;
    this.stopRequested = false;
    this.isInitialized = false;
    this.cacheReady = false;
    this.cacheDirty = false;
    this.yieldInterval = 1;
    // Changed to yield after every document for smoother UI responsiveness
    this.isSaving = false;
    // Prevent concurrent cache saves
    this.useWordBasedCandidates = true;
    // Enable fast word-based candidate selection
    // Current indexing state
    this.currentIndexingFile = null;
    // Adaptive stopwords (reusing from BloomFilterSimilarityProvider)
    this.wordFrequencies = /* @__PURE__ */ new Map();
    this.wordDocumentCount = /* @__PURE__ */ new Map();
    this.commonWords = /* @__PURE__ */ new Set();
    this.totalDocuments = 0;
    this.commonWordsThreshold = 0.4;
    // Reduced from 0.5 to filter more words
    this.commonWordsComputed = false;
    this.minWordLength = 2;
    this.maxStopwords = WORD_FILTERING.MAX_STOPWORDS;
    // Increased from 200 to filter more common words
    this.maxWordFrequencyEntries = 5e4;
    // Limit word frequency tracking to prevent memory leaks
    // In-memory similarity cache with TTL
    this.similarityCache = /* @__PURE__ */ new Map();
    this.lastCacheCleanup = Date.now();
    this.vault = vault;
    this.config = config;
    this.ngramSizes = config.ngramSizes;
    this.bloomSizes = config.bloomSizes;
    this.hashFunctions = config.hashFunctions;
    this.similarityThreshold = config.similarityThreshold;
    this.adaptiveParameters = config.adaptiveParameters !== false;
    if (config.parameterUpdateInterval) {
      this.parameterUpdateInterval = config.parameterUpdateInterval;
    }
    if (config.commonWordsThreshold) {
      this.commonWordsThreshold = config.commonWordsThreshold;
    }
    if (config.maxStopwords) {
      this.maxStopwords = config.maxStopwords;
    }
    if (config.minWordLength) {
      this.minWordLength = config.minWordLength;
    }
    if (config.yieldInterval) {
      this.yieldInterval = config.yieldInterval;
    }
    if (config.useWordBasedCandidates !== void 0) {
      this.useWordBasedCandidates = config.useWordBasedCandidates;
    }
    if (vault.adapter && vault.configDir) {
      try {
        const configDir = this.validateConfigDir(vault.configDir);
        this.cacheFilePath = `${configDir}${CACHE.RELATIVE_PATH}${CACHE.FILENAME}`;
        logIfDebugModeEnabled(`Cache path set to: ${this.cacheFilePath}`);
      } catch (error) {
        handleValidationError(error, "cache path setup", vault.configDir);
        this.cacheFilePath = void 0;
      }
    } else {
      console.warn("Vault adapter or configDir not available, cache will be disabled");
      this.cacheFilePath = void 0;
    }
    logIfDebugModeEnabled(`Created MultiResolutionBloomFilterProvider with:
      - n-gram size: ${this.ngramSizes[0]}
      - bloom size: ${this.bloomSizes[0]}
      - hash functions: ${this.hashFunctions[0]}
      - similarity threshold: ${this.similarityThreshold}
      - adaptive parameters: ${this.adaptiveParameters}
      - parameter update interval: ${this.parameterUpdateInterval} documents
      - adaptive stopwords: true (max: ${this.maxStopwords}, threshold: ${this.commonWordsThreshold * 100}%)
      - word-based candidate selection: ${this.useWordBasedCandidates}`);
  }
  /**
   * Initialize the similarity provider by processing all markdown files
   * @param onProgress Callback function for reporting progress
   */
  async initialize(onProgress) {
    if (this.isInitialized)
      return;
    this.stopRequested = false;
    try {
      const totalFiles = this.vault.getMarkdownFiles().length;
      if (onProgress) {
        onProgress(0, totalFiles);
      }
      logIfDebugModeEnabled("Attempting to load from cache...");
      let cachedLoaded = false;
      try {
        cachedLoaded = await this.loadFromCache();
        logIfDebugModeEnabled(`Cache loading completed, result: ${cachedLoaded}`);
      } catch (error) {
        logIfDebugModeEnabled(`Cache loading failed with error: ${error}`);
        cachedLoaded = false;
      }
      if (cachedLoaded) {
        logIfDebugModeEnabled(`Index loaded from cache: ${this.bloomFilters.size} documents`);
        this.isInitialized = true;
        if (onProgress) {
          onProgress(totalFiles, totalFiles);
        }
        return;
      }
      const markdownFiles = this.vault.getMarkdownFiles();
      logIfDebugModeEnabled(`Starting fresh indexing: ${totalFiles} markdown files`);
      const yield_to_main = async () => {
        await new Promise((resolve) => setTimeout(resolve, 15));
      };
      const batchSize = BATCH_PROCESSING.SMALL_BATCH_SIZE;
      let processedCount = 0;
      const yieldWithDuration = async (ms) => {
        await new Promise((resolve) => setTimeout(resolve, ms));
      };
      const filesToProcess = markdownFiles;
      logIfDebugModeEnabled(`Single pass indexing: ${totalFiles} files`);
      for (let i = 0; i < filesToProcess.length; i += batchSize) {
        if (this.stopRequested) {
          logIfDebugModeEnabled("Initialization stopped by user");
          return;
        }
        const batch = filesToProcess.slice(i, Math.min(i + batchSize, filesToProcess.length));
        if (onProgress) {
          onProgress(processedCount, totalFiles);
        }
        await yieldWithDuration(20);
        for (const file of batch) {
          if (this.stopRequested) {
            logIfDebugModeEnabled("Initialization stopped by user during batch processing");
            return;
          }
          try {
            this.currentIndexingFile = file.path;
            const content = await this.vault.cachedRead(file);
            const fileName = file.basename;
            const enhancedContent = `${fileName} ${content}`;
            await this.processDocument(file.path, enhancedContent);
            processedCount++;
            if (onProgress && (processedCount % 3 === 0 || processedCount === filesToProcess.length)) {
              onProgress(processedCount, totalFiles, file.path);
            }
            if (processedCount % 5 === 0) {
              await yieldWithDuration(10);
            }
            if (processedCount % 50 === 0) {
              this.cacheDirty = true;
              await this.saveToCache();
            }
          } catch (error) {
            console.error(`Error processing file ${file.path}:`, error);
          }
        }
        if (i % (batchSize * 2) === 0) {
          await yieldWithDuration(20);
        }
      }
      this.currentIndexingFile = null;
      await this.saveToCache();
      logIfDebugModeEnabled(`Indexing complete: ${this.bloomFilters.size} documents processed`);
      this.isInitialized = true;
    } catch (error) {
      console.error("Error during initialization:", error);
      throw error;
    }
  }
  /**
   * Stop any ongoing initialization
   */
  stop() {
    this.stopRequested = true;
    if (isDebugMode()) {
      logIfDebugModeEnabled("Stop requested for ongoing indexing operation");
    }
  }
  // Progressive indexing method removed - using single optimized pass only
  /**
   * Force a complete reindexing of all files
   * @param onProgress Progress callback
   */
  async forceReindex(onProgress) {
    this.stopRequested = false;
    this.bloomFilters.clear();
    this.documentNgrams.clear();
    this.commonWords.clear();
    this.commonWordsComputed = false;
    this.totalDocuments = 0;
    this.wordCandidateSelector.clear();
    this.cacheDirty = true;
    this.isInitialized = false;
    try {
      return await this.initialize(onProgress);
    } catch (error) {
      logIfDebugModeEnabled(`Error during initialization: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }
  /**
   * Check if a file is indexed
   * @param file File to check
   */
  isFileIndexed(file) {
    return this.bloomFilters.has(file.path);
  }
  /**
   * Get candidate similar files for a given file
   * Implements the SimilarityProvider interface
   * @param file The file to find candidates for
   * @returns Array of potential similar files
   */
  async getCandidateFiles(file) {
    if (!this.isInitialized) {
      if (isDebugMode()) {
        logIfDebugModeEnabled(`Provider not initialized yet, returning empty candidates list for ${file.path}`);
      }
      return [];
    }
    const availableIndexSize = this.bloomFilters.size;
    if (availableIndexSize === 0) {
      return [];
    }
    try {
      if (!this.bloomFilters.has(file.path)) {
        if (isDebugMode()) {
          logIfDebugModeEnabled(`File ${file.path} not in index yet, will process on-demand`);
          const indexedFiles = Array.from(this.bloomFilters.keys());
          logIfDebugModeEnabled(`Files currently in index (${indexedFiles.length} total):`);
          indexedFiles.forEach((indexedFile) => {
            logIfDebugModeEnabled(`  - ${indexedFile}`);
          });
        }
        return [];
      }
      try {
        const maxResults = this.config.maxSuggestions || 20;
        const corpusSize = this.bloomFilters.size;
        const enableSampling = this.config.enableSampling !== void 0 ? this.config.enableSampling : true;
        const sampleSizeThreshold = this.config.sampleSizeThreshold || 5e3;
        const maxSampleSize = this.config.maxSampleSize || 1e3;
        let candidateDocuments;
        const shouldSample = enableSampling && corpusSize > sampleSizeThreshold;
        if (shouldSample) {
          candidateDocuments = await this.getSmartCandidates(file.path, maxSampleSize);
          logIfDebugModeEnabled(`Large vault: using ${candidateDocuments.length} smart candidates from ${corpusSize} indexed files`);
        } else {
          candidateDocuments = Array.from(this.bloomFilters.keys()).filter((path) => path !== file.path);
        }
        const similarDocuments = await this.getSimilarDocuments(file.path, maxResults, void 0, candidateDocuments);
        const markdownFiles = this.vault.getMarkdownFiles();
        const pathToFile = /* @__PURE__ */ new Map();
        for (const mdFile of markdownFiles) {
          pathToFile.set(mdFile.path, mdFile);
        }
        const result = similarDocuments.map(([path, similarity]) => {
          const matchedFile = pathToFile.get(path);
          if (matchedFile) {
            matchedFile.similarity = similarity;
            return matchedFile;
          }
          return null;
        }).filter((f) => f !== null);
        if (isDebugMode()) {
          logIfDebugModeEnabled(`Found ${result.length} candidate files for ${file.path}`);
        }
        return result;
      } catch (error) {
        console.error(`Error in similarity calculation for ${file.path}:`, error);
        return [];
      }
    } catch (error) {
      console.error(`Error getting candidate files for ${file.path}:`, error);
      return [];
    }
  }
  /**
   * Compute similarity between two files
   * Implements the SimilarityProvider interface
   * @param file1 First file
   * @param file2 Second file
   * @returns Similarity info with score and common terms
   */
  async computeCappedCosineSimilarity(file1, file2) {
    if (!this.isInitialized) {
      return { similarity: 0 };
    }
    try {
      if (!this.bloomFilters.has(file1.path)) {
        const content1 = await this.vault.cachedRead(file1);
        this.processDocument(file1.path, content1);
      }
      if (!this.bloomFilters.has(file2.path)) {
        const content2 = await this.vault.cachedRead(file2);
        this.processDocument(file2.path, content2);
      }
      const similarity = this.calculateSimilarity(file1.path, file2.path);
      const commonTerms = this.extractCommonTerms(file1.path, file2.path);
      return {
        similarity
      };
    } catch (error) {
      console.error(`Error computing similarity between ${file1.path} and ${file2.path}:`, error);
      return { similarity: 0 };
    }
  }
  /**
   * Extract common terms between two documents
   * @param docId1 First document ID
   * @param docId2 Second document ID
   * @returns Array of common terms
   */
  extractCommonTerms(docId1, docId2) {
    if (!this.documentNgrams.has(docId1) || !this.documentNgrams.has(docId2)) {
      return [];
    }
    try {
      const ngrams1Map = this.documentNgrams.get(docId1);
      const ngrams2Map = this.documentNgrams.get(docId2);
      if (!ngrams1Map || !ngrams2Map) {
        return [];
      }
      const ngramSize1 = Array.from(ngrams1Map.keys())[0];
      const ngramSize2 = Array.from(ngrams2Map.keys())[0];
      if (ngramSize1 === void 0 || ngramSize2 === void 0) {
        return [];
      }
      const ngrams1 = ngrams1Map.get(ngramSize1);
      const ngrams2 = ngrams2Map.get(ngramSize2);
      if (!ngrams1 || !ngrams2) {
        return [];
      }
      const commonNgrams = [...ngrams1].filter((n) => ngrams2.has(n));
      return commonNgrams.slice(0, 10);
    } catch (error) {
      console.error(`Error extracting common terms for ${docId1} and ${docId2}:`, error);
      return [];
    }
  }
  /**
   * Process a document and create bloom filters with memory safety
   * @param docId Document identifier
   * @param text Document text
   */
  async processDocument(docId, text) {
    if (this.documentsProcessed > 0 && this.documentsProcessed % MEMORY_LIMITS.MAX_DOCUMENTS_BEFORE_CLEANUP === 0) {
      logIfDebugModeEnabled(`Memory circuit breaker: triggering cleanup after ${this.documentsProcessed} documents`);
      this.performMemoryCleanup();
    }
    const maxDocSize = MEMORY_LIMITS.MAX_DOCUMENT_SIZE_MB * 1024 * 1024;
    if (text.length > maxDocSize) {
      logIfDebugModeEnabled(`Skipping document ${docId} - too large: ${text.length} chars (max: ${maxDocSize})`);
      return;
    }
    this.cacheDirty = true;
    const startTime = performance.now();
    const yieldWithDuration = async (ms) => {
      await new Promise((resolve) => setTimeout(resolve, ms));
    };
    await yieldWithDuration(TIMING.YIELD_DURATION_MS);
    this.documentsProcessed++;
    const isLargeVault = this.bloomFilters.size > WORD_FILTERING.LARGE_VAULT_THRESHOLD;
    const processLimit = isLargeVault ? TEXT_PROCESSING.LARGE_VAULT_DOCUMENT_LIMIT : TEXT_PROCESSING.LARGE_DOCUMENT_LIMIT;
    const isLargeDocument = text.length > processLimit;
    if (isLargeDocument) {
      logIfDebugModeEnabled(`Large document detected (${text.length} chars), limiting to ${processLimit} chars${isLargeVault ? " (low fidelity mode)" : ""}`);
    }
    const limitedText = isLargeDocument ? this.smartTruncateText(text, processLimit) : text;
    this.trackWordFrequencies(docId, limitedText);
    await yieldWithDuration(TIMING.YIELD_DURATION_MS);
    if (this.totalDocuments >= 30 && !this.commonWordsComputed) {
      this.computeCommonWords();
      await yieldWithDuration(TIMING.EXTENDED_YIELD_DURATION_MS);
    }
    const filterSize = isLargeVault ? BLOOM_FILTER.LARGE_VAULT_FILTER_SIZE : BLOOM_FILTER.DEFAULT_FILTER_SIZE;
    const filter = new SingleBloomFilter(
      [3],
      // Single n-gram size (kept as array for backward compatibility)
      [filterSize],
      // Adaptive bloom filter size based on vault size
      [3]
      // Hash functions
    );
    const processed = this.preprocessText(limitedText);
    await yieldWithDuration(TIMING.YIELD_DURATION_MS);
    const words = processed.split(/\s+/);
    const CHUNK_SIZE = TIMING.MAX_OPERATIONS_BEFORE_YIELD;
    for (let i = 0; i < words.length; i += CHUNK_SIZE) {
      const chunk = words.slice(i, i + CHUNK_SIZE).join(" ");
      filter.addText(chunk);
      await yieldWithDuration(TIMING.MIN_YIELD_TIME_MS);
    }
    this.bloomFilters.set(docId, filter);
    if (this.useWordBasedCandidates) {
      await yieldWithDuration(5);
      this.wordCandidateSelector.addDocument(docId, limitedText);
    }
    const endTime = performance.now();
    await yieldWithDuration(5);
    if (isDebugMode()) {
      logIfDebugModeEnabled(`Processed document ${docId} in ${(endTime - startTime).toFixed(2)}ms`);
    }
  }
  /**
   * Extract n-grams from text for a specific n-gram size
   * @param text Input text
   * @param ngramSize Size of n-grams to extract
   * @returns Set of n-grams
   */
  extractNgrams(text, ngramSize) {
    const chars = text.toLowerCase().normalize("NFC").replace(/\s+/g, " ");
    const ngrams = /* @__PURE__ */ new Set();
    for (let i = 0; i <= [...chars].length - ngramSize; i++) {
      const ngram = [...chars].slice(i, i + ngramSize).join("");
      if (ngram.length === ngramSize) {
        ngrams.add(ngram);
      }
    }
    return ngrams;
  }
  /**
   * Preprocess text by removing common words
   * @param text Input text
   * @returns Preprocessed text
   */
  preprocessText(text) {
    const processed = tokenize(text);
    const words = processed.toLowerCase().split(/\s+/);
    let meaningfulWords;
    if (this.commonWordsComputed) {
      meaningfulWords = words.filter(
        (word) => word.length > this.minWordLength && !this.commonWords.has(word)
      );
    } else {
      meaningfulWords = words.filter((word) => word.length > this.minWordLength);
    }
    return meaningfulWords.join(" ");
  }
  /**
   * Calculate similarity between two documents
   * @param docId1 First document ID
   * @param docId2 Second document ID
   * @returns Similarity score between 0 and 1
   */
  calculateSimilarity(docId1, docId2) {
    const cacheKey = docId1 < docId2 ? `${docId1}|${docId2}` : `${docId2}|${docId1}`;
    const cached = this.similarityCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE.SIMILARITY_TTL_MS) {
      return cached.similarity;
    }
    const startTime = performance.now();
    const filter1 = this.bloomFilters.get(docId1);
    const filter2 = this.bloomFilters.get(docId2);
    if (!filter1 || !filter2) {
      if (isDebugMode()) {
        if (!filter1)
          logIfDebugModeEnabled(`Document ${docId1} not found`);
        if (!filter2)
          logIfDebugModeEnabled(`Document ${docId2} not found`);
      }
      return 0;
    }
    const similarity = filter1.similarity(filter2);
    this.similarityCache.set(cacheKey, {
      similarity,
      timestamp: Date.now()
    });
    this.cleanupCacheIfNeeded();
    const endTime = performance.now();
    if (isDebugMode()) {
      logIfDebugModeEnabled(`Similarity calculation for ${docId1} and ${docId2}: ${(similarity * 100).toFixed(2)}% in ${(endTime - startTime).toFixed(2)}ms`);
    }
    return similarity;
  }
  /**
   * Get smart candidates for similarity comparison in large vaults
   * Uses word-based inverted index for ultra-fast candidate selection
   * @param queryDocId Query document ID  
   * @param maxCandidates Maximum number of candidates to return
   * @returns Array of candidate document IDs
   */
  async getSmartCandidates(queryDocId, maxCandidates) {
    const startTime = performance.now();
    if (this.useWordBasedCandidates && this.wordCandidateSelector.isDocumentIndexed(queryDocId)) {
      const numSampleWords = Math.min(
        WORD_INDEX.MAX_SAMPLE_WORDS,
        Math.max(
          WORD_INDEX.MIN_SAMPLE_WORDS,
          Math.floor(Math.sqrt(maxCandidates / 10))
        )
      );
      const wordBasedCandidates = this.wordCandidateSelector.getFastCandidates(
        queryDocId,
        Math.ceil(maxCandidates * 0.8),
        // Use 80% of requested candidates from word sampling
        numSampleWords
      );
      const recentFiles2 = this.vault.getMarkdownFiles().filter((file) => file.stat.mtime > Date.now() - 30 * 24 * 60 * 60 * 1e3).slice(0, Math.ceil(maxCandidates * 0.2)).map((file) => file.path).filter((path) => this.bloomFilters.has(path) && path !== queryDocId);
      const allCandidates = /* @__PURE__ */ new Set([...wordBasedCandidates, ...recentFiles2]);
      const result2 = Array.from(allCandidates).slice(0, maxCandidates);
      const endTime2 = performance.now();
      logPerformance(`Word-based candidate selection: ${result2.length} candidates in ${(endTime2 - startTime).toFixed(1)}ms`);
      return result2;
    }
    const queryFilter = this.bloomFilters.get(queryDocId);
    if (!queryFilter) {
      return [];
    }
    const allDocIds = Array.from(this.bloomFilters.keys()).filter((id) => id !== queryDocId);
    const candidates = /* @__PURE__ */ new Set();
    const fastCandidates = [];
    for (const docId of allDocIds) {
      const otherFilter = this.bloomFilters.get(docId);
      if (otherFilter) {
        const intersection = queryFilter.fastIntersectionCount(otherFilter);
        if (intersection > 0) {
          fastCandidates.push([docId, intersection]);
        }
      }
    }
    fastCandidates.sort((a, b) => b[1] - a[1]);
    const topFastCandidates = fastCandidates.slice(0, Math.min(Math.ceil(maxCandidates * 0.7), 700)).map(([docId]) => docId);
    topFastCandidates.forEach((docId) => candidates.add(docId));
    const recentFiles = this.vault.getMarkdownFiles().filter((file) => file.stat.mtime > Date.now() - 30 * 24 * 60 * 60 * 1e3).slice(0, Math.ceil(maxCandidates * 0.2)).map((file) => file.path).filter((path) => this.bloomFilters.has(path) && path !== queryDocId);
    recentFiles.forEach((path) => candidates.add(path));
    const remaining = allDocIds.filter((docId) => !candidates.has(docId));
    const randomSampleSize = Math.min(
      Math.ceil(maxCandidates * 0.1),
      remaining.length,
      100
    );
    for (let i = 0; i < randomSampleSize; i++) {
      const randomIndex = Math.floor(Math.random() * remaining.length);
      candidates.add(remaining[randomIndex]);
    }
    const result = Array.from(candidates).slice(0, maxCandidates);
    const endTime = performance.now();
    logPerformance(`Bloom filter candidate selection: ${result.length} candidates in ${(endTime - startTime).toFixed(1)}ms`);
    return result;
  }
  /**
   * Get most similar documents to a query document with CPU throttling
   * @param queryDocId Query document ID
   * @param limit Maximum number of results
   * @param sampleSize Optional: Number of documents to sample when corpus is large (deprecated)
   * @param candidateDocIds Optional: Specific candidate documents to compare against
   * @returns Array of [docId, similarity] pairs, sorted by similarity
   */
  async getSimilarDocuments(queryDocId, limit = 10, sampleSize, candidateDocIds) {
    const startTime = performance.now();
    const queryFilter = this.bloomFilters.get(queryDocId);
    if (!queryFilter) {
      logIfDebugModeEnabled(`Query document ${queryDocId} not found`);
      return [];
    }
    const results = [];
    let comparisons = 0;
    let skippedComparisons = 0;
    let operationsSinceYield = 0;
    let documentsToProcess;
    if (candidateDocIds && candidateDocIds.length > 0) {
      documentsToProcess = candidateDocIds.filter((docId) => docId !== queryDocId && this.bloomFilters.has(docId)).map((docId) => [docId, this.bloomFilters.get(docId)]);
      logIfDebugModeEnabled(`Using ${candidateDocIds.length} smart candidates for similarity comparison`);
    } else {
      const corpusSize = this.bloomFilters.size;
      const shouldSample = sampleSize && corpusSize > sampleSize;
      const docEntries = shouldSample ? Array.from(this.bloomFilters.entries()) : null;
      documentsToProcess = shouldSample ? this.sampleDocuments(docEntries, sampleSize, queryDocId) : this.bloomFilters.entries();
      if (shouldSample) {
        logIfDebugModeEnabled(`Large corpus detected (${corpusSize} documents), sampling ${sampleSize} documents`);
      }
    }
    for (const [docId, filter] of documentsToProcess) {
      if (docId === queryDocId)
        continue;
      if (++operationsSinceYield >= TIMING.MAX_OPERATIONS_BEFORE_YIELD) {
        await new Promise((resolve) => setTimeout(resolve, TIMING.MIN_YIELD_TIME_MS));
        operationsSinceYield = 0;
      }
      comparisons++;
      try {
        const similarity = queryFilter.similarity(filter);
        if (similarity > 0) {
          results.push([docId, similarity]);
        }
      } catch (error) {
        skippedComparisons++;
        if (isDebugMode()) {
          logIfDebugModeEnabled(`Error comparing ${queryDocId} with ${docId}: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    }
    const sortedResults = results.sort((a, b) => b[1] - a[1]).slice(0, limit);
    const endTime = performance.now();
    logIfDebugModeEnabled(`Found ${sortedResults.length} similar documents to ${queryDocId}:
      - Compared with ${comparisons - skippedComparisons} documents (${skippedComparisons} skipped)
      - ${candidateDocIds ? `Using smart candidates (${candidateDocIds.length} candidates)` : "Using all documents"}
      - No threshold applied, showing top ${limit} non-zero matches
      - Time: ${(endTime - startTime).toFixed(2)}ms
      ${sortedResults.length > 0 ? `- Top match: ${sortedResults[0][0]} (${(sortedResults[0][1] * 100).toFixed(1)}%)` : ""}`);
    return sortedResults;
  }
  /**
   * Sample a subset of documents for similarity comparison
   * Uses pure random sampling to discover diverse connections
   * @param documents Array of [docId, filter] pairs
   * @param sampleSize Number of documents to sample
   * @param queryDocId The ID of the query document (to exclude)
   * @returns Array of sampled [docId, filter] pairs
   */
  sampleDocuments(documents, sampleSize, queryDocId) {
    const filteredDocs = documents.filter(([docId]) => docId !== queryDocId);
    if (filteredDocs.length <= sampleSize) {
      return filteredDocs;
    }
    const docsToSample = [...filteredDocs];
    for (let i = docsToSample.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [docsToSample[i], docsToSample[j]] = [docsToSample[j], docsToSample[i]];
    }
    return docsToSample.slice(0, sampleSize);
  }
  /**
   * Update parameters based on corpus analysis
   */
  updateParameters() {
    if (!this.adaptiveParameters || this.documentsProcessed < 25)
      return;
    const params = this.parameterCalculator.generateRecommendedParameters(0.05);
    logIfDebugModeEnabled(`Updating parameters after analyzing ${this.documentsProcessed} documents:
      - n-gram sizes: [${this.ngramSizes.join(", ")}] -> [${params.ngramSizes.join(", ")}]
      - bloom sizes: [${this.bloomSizes.join(", ")}] (keeping fixed size for compatibility)
      - hash functions: [${this.hashFunctions.join(", ")}] -> [${params.hashFunctions.join(", ")}]
      - similarity threshold: ${this.similarityThreshold} -> ${params.similarityThreshold}`);
    this.ngramSizes = params.ngramSizes;
    this.hashFunctions = params.hashFunctions;
    this.similarityThreshold = params.similarityThreshold;
  }
  /**
   * Clean up expired entries from the similarity cache
   */
  cleanupCacheIfNeeded() {
    const now = Date.now();
    if (now - this.lastCacheCleanup < 5 * 60 * 1e3) {
      return;
    }
    if (this.similarityCache.size < CACHE.MEMORY_CACHE_CLEANUP_THRESHOLD) {
      this.lastCacheCleanup = now;
      return;
    }
    const initialSize = this.similarityCache.size;
    const cutoffTime = now - CACHE.SIMILARITY_TTL_MS;
    for (const [key, entry] of this.similarityCache.entries()) {
      if (entry.timestamp < cutoffTime) {
        this.similarityCache.delete(key);
      }
    }
    if (this.similarityCache.size > CACHE.MAX_MEMORY_CACHE_ENTRIES) {
      const entries = Array.from(this.similarityCache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      const entriesToRemove = this.similarityCache.size - CACHE.MAX_MEMORY_CACHE_ENTRIES;
      for (let i = 0; i < entriesToRemove; i++) {
        this.similarityCache.delete(entries[i][0]);
      }
    }
    const finalSize = this.similarityCache.size;
    this.lastCacheCleanup = now;
    if (isDebugMode() && initialSize !== finalSize) {
      logIfDebugModeEnabled(`Similarity cache cleanup: ${initialSize} -> ${finalSize} entries`);
    }
  }
  /**
   * Track word frequencies and document occurrences to identify common words
   * @param docId Document identifier
   * @param text Document text
   */
  trackWordFrequencies(docId, text) {
    var _a;
    if (this.commonWordsComputed)
      return;
    if (this.wordFrequencies.size >= this.maxWordFrequencyEntries) {
      this.computeCommonWords();
      return;
    }
    const processed = tokenize(text);
    const words = processed.toLowerCase().split(/\s+/);
    const uniqueWords = /* @__PURE__ */ new Set();
    for (const word of words) {
      if (word.length <= this.minWordLength)
        continue;
      if (!this.wordFrequencies.has(word) && this.wordFrequencies.size >= this.maxWordFrequencyEntries) {
        break;
      }
      this.wordFrequencies.set(word, (this.wordFrequencies.get(word) || 0) + 1);
      uniqueWords.add(word);
    }
    for (const word of uniqueWords) {
      if (!this.wordDocumentCount.has(word)) {
        if (this.wordDocumentCount.size >= this.maxWordFrequencyEntries) {
          break;
        }
        this.wordDocumentCount.set(word, /* @__PURE__ */ new Set());
      }
      (_a = this.wordDocumentCount.get(word)) == null ? void 0 : _a.add(docId);
    }
    this.totalDocuments++;
  }
  /**
   * Compute common words based on frequency and document occurrence
   */
  computeCommonWords() {
    var _a;
    if (this.commonWordsComputed)
      return;
    if (this.totalDocuments < 10)
      return;
    const wordScores = /* @__PURE__ */ new Map();
    for (const [word, frequency] of this.wordFrequencies.entries()) {
      const docsWithWord = ((_a = this.wordDocumentCount.get(word)) == null ? void 0 : _a.size) || 0;
      const documentCoverage = docsWithWord / this.totalDocuments;
      if (docsWithWord < 5)
        continue;
      wordScores.set(word, documentCoverage);
    }
    const sortedWords = Array.from(wordScores.entries()).sort((a, b) => b[1] - a[1]);
    for (const [word, score] of sortedWords) {
      if (score >= this.commonWordsThreshold || this.commonWords.size < this.maxStopwords) {
        this.commonWords.add(word);
      } else {
        break;
      }
    }
    this.commonWordsComputed = true;
    logIfDebugModeEnabled(`Computed ${this.commonWords.size} common words from ${this.totalDocuments} documents`);
    if (this.commonWords.size <= 50) {
      logIfDebugModeEnabled(`Common words: ${Array.from(this.commonWords).join(", ")}`);
    } else {
      logIfDebugModeEnabled(`Top 50 common words: ${Array.from(this.commonWords).slice(0, 50).join(", ")}...`);
    }
    this.wordFrequencies.clear();
    this.wordDocumentCount.clear();
  }
  /**
   * Get statistics about the provider
   */
  getStats() {
    const stats = {
      documentsProcessed: this.documentsProcessed,
      ngramSizes: this.ngramSizes,
      bloomSizes: this.bloomSizes,
      hashFunctions: this.hashFunctions,
      similarityThreshold: this.similarityThreshold,
      adaptiveParameters: this.adaptiveParameters,
      adaptiveStopwords: true,
      stopwordsComputed: this.commonWordsComputed,
      stopwordsCount: this.commonWords.size,
      stopwordsThreshold: this.commonWordsThreshold,
      maxStopwords: this.maxStopwords,
      documentsAnalyzed: this.totalDocuments,
      indexing: {
        currentFile: this.currentIndexingFile
      },
      memoryUsage: {
        totalBytes: 0,
        totalKB: 0,
        totalMB: 0
      }
    };
    let totalMemoryBytes = 0;
    for (const filter of this.bloomFilters.values()) {
      const filterStats = filter.getStats();
      totalMemoryBytes += filterStats.totalMemoryBytes;
    }
    stats.memoryUsage.totalBytes = totalMemoryBytes;
    stats.memoryUsage.totalKB = totalMemoryBytes / 1024;
    stats.memoryUsage.totalMB = totalMemoryBytes / (1024 * 1024);
    stats.corpusStats = this.parameterCalculator.getStats();
    if (this.useWordBasedCandidates) {
      stats.wordIndex = this.wordCandidateSelector.getStats();
    }
    return stats;
  }
  /**
   * Clear all bloom filters and free memory
   */
  clear() {
    this.bloomFilters.clear();
    this.documentNgrams.clear();
    this.currentIndexingFile = null;
    this.wordFrequencies.clear();
    this.wordDocumentCount.clear();
    this.commonWords.clear();
    this.commonWordsComputed = false;
    this.totalDocuments = 0;
    this.wordCandidateSelector.clear();
    this.similarityCache.clear();
    this.cacheDirty = true;
  }
  /**
   * Perform memory cleanup - called by circuit breaker
   */
  performMemoryCleanup() {
    try {
      if (this.wordFrequencies.size > 1e3) {
        this.wordFrequencies.clear();
        logIfDebugModeEnabled("Cleared word frequencies to save memory");
      }
      if (this.wordDocumentCount.size > 1e3) {
        this.wordDocumentCount.clear();
        logIfDebugModeEnabled("Cleared word document count to save memory");
      }
      if (typeof global !== "undefined" && global.gc) {
        global.gc();
        logIfDebugModeEnabled("Triggered garbage collection");
      }
      if (typeof process !== "undefined" && process.memoryUsage) {
        const memUsage = process.memoryUsage();
        const memMB = Math.round(memUsage.heapUsed / 1024 / 1024);
        logIfDebugModeEnabled(`Memory usage after cleanup: ${memMB}MB`);
        if (memMB > MEMORY_LIMITS.MAX_MEMORY_MB) {
          logIfDebugModeEnabled("Memory usage still high, performing aggressive cleanup");
          this.clear();
        }
      }
    } catch (error) {
      console.error("Error during memory cleanup:", error);
    }
  }
  /**
   * Get the number of documents indexed
   */
  size() {
    return this.bloomFilters.size;
  }
  /**
   * Save the bloom filter index to disk cache with corruption prevention
   */
  async saveToCache() {
    if (!this.cacheFilePath || !this.vault.adapter) {
      logIfDebugModeEnabled("Cannot save cache: no cache path or vault adapter");
      return false;
    }
    const isDirValid = await this.validateCacheDirectory();
    if (!isDirValid) {
      console.error("Cache directory is not accessible, cannot save cache");
      return false;
    }
    if (!this.cacheDirty) {
      logIfDebugModeEnabled("Cache is not dirty, skipping save");
      return true;
    }
    if (this.isSaving) {
      logIfDebugModeEnabled("Cache save already in progress, skipping duplicate save");
      return true;
    }
    this.isSaving = true;
    try {
      logIfDebugModeEnabled(`Saving bloom filter cache to ${this.cacheFilePath}`);
      const cache = {
        version: 1,
        timestamp: Date.now(),
        params: {
          ngramSizes: this.ngramSizes,
          bloomSizes: this.bloomSizes,
          hashFunctions: this.hashFunctions,
          similarityThreshold: this.similarityThreshold
        },
        stats: {
          documentCount: this.bloomFilters.size,
          commonWordsComputed: this.commonWordsComputed,
          commonWordsCount: this.commonWords.size,
          totalDocuments: this.totalDocuments
        },
        // Serialize bloom filters
        filters: {},
        // Serialize common words
        commonWords: Array.from(this.commonWords)
      };
      for (const [docId, filter] of this.bloomFilters.entries()) {
        const filterData = {};
        filterData.ngramSizes = filter.ngramSizes;
        for (const ngramSize of filter.ngramSizes) {
          const bloomFilter = filter.filters.get(ngramSize);
          if (bloomFilter) {
            const bitArray = Array.from(bloomFilter.getBitArray());
            filterData[`bloom_${ngramSize}`] = bitArray;
          }
        }
        cache.filters[docId] = filterData;
      }
      const cacheDir = this.cacheFilePath.substring(0, this.cacheFilePath.lastIndexOf("/"));
      await this.vault.adapter.mkdir(cacheDir);
      const tempCachePath = `${this.cacheFilePath}.tmp`;
      const cacheContent = JSON.stringify(cache);
      try {
        JSON.parse(cacheContent);
      } catch (parseError) {
        throw new Error(`Cache serialization validation failed: ${parseError}`);
      }
      await this.executeFileOperationWithRetry(
        () => this.vault.adapter.write(tempCachePath, cacheContent),
        "Cache temp save operation"
      );
      const tempContent = await this.executeFileOperationWithRetry(
        () => this.vault.adapter.read(tempCachePath),
        "Cache temp verification"
      );
      try {
        const verifyCache = JSON.parse(tempContent);
        if (verifyCache.version !== cache.version || Object.keys(verifyCache.filters).length !== Object.keys(cache.filters).length) {
          throw new Error("Cache verification failed: data mismatch");
        }
      } catch (verifyError) {
        await this.vault.adapter.remove(tempCachePath).catch(() => {
        });
        throw new Error(`Cache verification failed: ${verifyError}`);
      }
      await this.executeFileOperationWithRetry(
        async () => {
          const exists = await this.vault.adapter.exists((0, import_obsidian3.normalizePath)(this.cacheFilePath));
          if (exists) {
            await this.vault.adapter.remove((0, import_obsidian3.normalizePath)(this.cacheFilePath));
          }
          await this.vault.adapter.write(this.cacheFilePath, tempContent);
          await this.vault.adapter.remove(tempCachePath);
        },
        "Cache atomic move operation"
      );
      logIfDebugModeEnabled(`Bloom filter cache saved: ${Object.keys(cache.filters).length} documents`);
      this.cacheDirty = false;
      this.cacheReady = true;
      return true;
    } catch (error) {
      handleCacheError(error, "save cache", { cacheFilePath: this.cacheFilePath });
      try {
        const tempCachePath = `${this.cacheFilePath}.tmp`;
        await this.vault.adapter.remove(tempCachePath);
      } catch (cleanupError) {
      }
      return false;
    } finally {
      this.isSaving = false;
    }
  }
  /**
   * Load the bloom filter index from disk cache 
   */
  async loadFromCache() {
    logIfDebugModeEnabled(`loadFromCache() called`);
    if (!this.cacheFilePath || !this.vault.adapter) {
      logIfDebugModeEnabled(`Cache loading failed: no cache path (${this.cacheFilePath}) or vault adapter (${!!this.vault.adapter})`);
      return false;
    }
    logIfDebugModeEnabled(`Attempting to load cache from - normalized: ${(0, import_obsidian3.normalizePath)(this.cacheFilePath)}`);
    try {
      const exists = await this.executeFileOperationWithRetry(
        () => this.vault.adapter.exists((0, import_obsidian3.normalizePath)(this.cacheFilePath)),
        "Cache existence check"
      );
      if (!exists) {
        logIfDebugModeEnabled("Cache file does not exist - will trigger fresh indexing");
        return false;
      }
      logIfDebugModeEnabled("Cache file exists, proceeding to read and parse");
      const cacheData = await this.executeFileOperationWithRetry(
        () => this.vault.adapter.read(this.cacheFilePath),
        "Cache read operation"
      );
      let cache;
      try {
        cache = JSON.parse(cacheData);
      } catch (error) {
        logIfDebugModeEnabled("Cache file contains invalid JSON, deleting corrupt cache");
        this.deleteCache();
        return false;
      }
      const validationResult = this.validateCacheStructure(cache);
      if (!validationResult.isValid) {
        logIfDebugModeEnabled(`Cache validation failed: ${validationResult.reason}`);
        this.deleteCache();
        return false;
      }
      logIfDebugModeEnabled("Cache structure validation passed");
      const params = cache.params;
      if (!this.areArraysEqual(params.ngramSizes, this.ngramSizes) || !this.areArraysEqual(params.hashFunctions, this.hashFunctions)) {
        logIfDebugModeEnabled(`Cache parameter mismatch detected: ngramSizes cache=[${params.ngramSizes}] vs current=[${this.ngramSizes}], hashFunctions cache=[${params.hashFunctions}] vs current=[${this.hashFunctions}]`);
        this.deleteCache();
        return false;
      }
      if (params.bloomSizes && !this.areArraysEqual(params.bloomSizes, this.bloomSizes)) {
        logIfDebugModeEnabled(`Bloom filter size mismatch detected: cache=[${params.bloomSizes}] vs current=[${this.bloomSizes}]`);
        this.deleteCache();
        return false;
      }
      if (params.similarityThreshold !== this.similarityThreshold) {
        logIfDebugModeEnabled(`Similarity threshold changed from ${params.similarityThreshold} to ${this.similarityThreshold}, continuing with cache`);
      }
      const bloomSizes = cache.params.bloomSizes;
      if (bloomSizes && Array.isArray(bloomSizes) && bloomSizes.length > 0) {
        const firstSize = bloomSizes[0];
        const allSame = bloomSizes.every((size) => size === firstSize);
        if (!allSame) {
          this.deleteCache();
          return false;
        }
      }
      this.bloomFilters.clear();
      this.documentNgrams.clear();
      this.commonWords.clear();
      if (cache.commonWords && Array.isArray(cache.commonWords)) {
        for (const word of cache.commonWords) {
          this.commonWords.add(word);
        }
        this.commonWordsComputed = true;
      }
      if (cache.stats && cache.stats.totalDocuments) {
        this.totalDocuments = cache.stats.totalDocuments;
      }
      let loadedCount = 0;
      let invalidEntryCount = 0;
      const documentsToRemove = [];
      for (const [docId, rawFilterData] of Object.entries(cache.filters)) {
        try {
          if (!rawFilterData || typeof rawFilterData !== "object") {
            documentsToRemove.push(docId);
            continue;
          }
          const filterData = rawFilterData;
          const ngramSizes = Array.isArray(filterData.ngramSizes) ? filterData.ngramSizes : this.ngramSizes;
          let hasValidData = false;
          for (const ngramSize of ngramSizes) {
            const bitArrayKey = `bloom_${ngramSize}`;
            if (filterData[bitArrayKey] && Array.isArray(filterData[bitArrayKey])) {
              hasValidData = true;
              break;
            }
          }
          if (!hasValidData) {
            documentsToRemove.push(docId);
            continue;
          }
          const filter = new SingleBloomFilter(
            ngramSizes,
            this.bloomSizes,
            this.hashFunctions
          );
          let filterRestored = false;
          for (const ngramSize of ngramSizes) {
            const bitArrayKey = `bloom_${ngramSize}`;
            if (filterData[bitArrayKey] && Array.isArray(filterData[bitArrayKey])) {
              const bloomFilter = filter.filters.get(ngramSize);
              if (bloomFilter) {
                try {
                  const expectedLength = this.bloomSizes[ngramSizes.indexOf(ngramSize)] / 32;
                  const actualLength = filterData[bitArrayKey].length;
                  if (actualLength !== expectedLength) {
                    documentsToRemove.push(docId);
                    break;
                  }
                  const bitArray = new Uint32Array(filterData[bitArrayKey]);
                  bloomFilter.setBitArray(bitArray);
                  filterRestored = true;
                } catch (bitArrayError) {
                  documentsToRemove.push(docId);
                  break;
                }
              }
            }
          }
          if (filterRestored && !documentsToRemove.includes(docId)) {
            this.bloomFilters.set(docId, filter);
            loadedCount++;
          }
        } catch (error) {
          documentsToRemove.push(docId);
          invalidEntryCount++;
          continue;
        }
      }
      logIfDebugModeEnabled(`Finished processing cache entries: ${loadedCount} loaded, ${invalidEntryCount} invalid, ${documentsToRemove.length} to remove`);
      if (documentsToRemove.length > 0) {
        console.info(`Removing ${documentsToRemove.length} invalid cache entries`);
        for (const docId of documentsToRemove) {
          if (cache.filters && cache.filters[docId]) {
            delete cache.filters[docId];
          }
        }
        this.cacheDirty = true;
        console.info(`Cache cleanup: removed ${documentsToRemove.length} invalid entries, successfully loaded ${loadedCount} documents`);
      }
      if (this.useWordBasedCandidates && loadedCount > 0) {
        logIfDebugModeEnabled("Repopulating word candidate selector from cached documents");
        let reprocessed = 0;
        for (const docId of this.bloomFilters.keys()) {
          try {
            const file = this.vault.getMarkdownFiles().find((f) => f.path === docId);
            if (file) {
              const content = await this.vault.cachedRead(file);
              const fileName = file.basename;
              const enhancedContent = `${fileName} ${content}`;
              this.wordCandidateSelector.addDocument(docId, enhancedContent);
              reprocessed++;
            }
          } catch (error) {
            logIfDebugModeEnabled(`Error repopulating word index for ${docId}: ${error}`);
          }
        }
        logIfDebugModeEnabled(`Repopulated word candidate selector with ${reprocessed} documents`);
      }
      this.cacheDirty = false;
      this.cacheReady = true;
      logIfDebugModeEnabled(`Cache loading result: ${loadedCount} documents loaded, returning ${loadedCount > 0}`);
      if (loadedCount === 0) {
        logIfDebugModeEnabled("Cache loaded but no documents found - this will trigger fresh indexing");
      }
      return loadedCount > 0;
    } catch (error) {
      console.error("Error loading bloom filter cache:", error);
      return false;
    }
  }
  /**
   * Helper method to compare arrays for equality
   */
  areArraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  /**
   * Manually save the cache to disk
   * This can be called externally to ensure the cache is saved
   */
  async saveCache() {
    return this.saveToCache();
  }
  /**
   * Validate and normalize the config directory path
   * @param configDir The config directory path to validate
   * @returns Normalized config directory path
   * @throws Error if the path is invalid
   */
  validateConfigDir(configDir) {
    if (!configDir || typeof configDir !== "string") {
      throw new Error("Config directory path is invalid or not provided");
    }
    const normalizedPath = (0, import_obsidian3.normalizePath)(configDir);
    if (normalizedPath.includes("..") || normalizedPath.includes("//")) {
      throw new Error("Config directory path contains invalid patterns");
    }
    if (normalizedPath.length < 3) {
      throw new Error("Config directory path is too short to be valid");
    }
    return normalizedPath;
  }
  /**
   * Validate cache directory exists and is writable
   * @returns Promise<boolean> indicating if cache directory is accessible
   */
  async validateCacheDirectory() {
    if (!this.cacheFilePath || !this.vault.adapter) {
      return false;
    }
    try {
      const cacheDir = this.cacheFilePath.substring(0, this.cacheFilePath.lastIndexOf("/"));
      const dirExists = await this.vault.adapter.exists((0, import_obsidian3.normalizePath)(cacheDir));
      if (!dirExists) {
        await this.vault.adapter.mkdir(cacheDir);
        logIfDebugModeEnabled(`Created cache directory: ${cacheDir}`);
      }
      const testFilePath = `${cacheDir}/.write-test-${Date.now()}`;
      try {
        await this.vault.adapter.write(testFilePath, "test");
        await this.vault.adapter.remove(testFilePath);
        return true;
      } catch (writeError) {
        console.error("Cache directory is not writable:", writeError);
        return false;
      }
    } catch (error) {
      console.error("Failed to validate cache directory:", error);
      return false;
    }
  }
  /**
   * Validate cache structure and content
   * @param cache The cache object to validate
   * @returns Validation result with success status and reason
   */
  validateCacheStructure(cache) {
    if (!cache || typeof cache !== "object") {
      return { isValid: false, reason: "Cache is not a valid object" };
    }
    if (!cache.version || typeof cache.version !== "number") {
      return { isValid: false, reason: "Cache version is missing or invalid" };
    }
    if (cache.version !== CACHE.VERSION) {
      return { isValid: false, reason: `Cache version mismatch: expected ${CACHE.VERSION}, got ${cache.version}` };
    }
    const requiredProperties = ["params", "filters", "stats", "timestamp"];
    for (const prop of requiredProperties) {
      if (!(prop in cache)) {
        return { isValid: false, reason: `Missing required property: ${prop}` };
      }
    }
    if (!cache.params || typeof cache.params !== "object") {
      return { isValid: false, reason: "Cache params is missing or invalid" };
    }
    const requiredParams = ["ngramSizes", "hashFunctions", "similarityThreshold"];
    for (const param of requiredParams) {
      if (!(param in cache.params)) {
        return { isValid: false, reason: `Missing required param: ${param}` };
      }
    }
    if (!cache.filters || typeof cache.filters !== "object") {
      return { isValid: false, reason: "Cache filters is missing or invalid" };
    }
    if (!cache.stats || typeof cache.stats !== "object") {
      return { isValid: false, reason: "Cache stats is missing or invalid" };
    }
    if (typeof cache.timestamp === "number") {
      const cacheAge = Date.now() - cache.timestamp;
      if (cacheAge > TIMING.CACHE_AGE_THRESHOLD_MS) {
        return { isValid: false, reason: `Cache is too old: ${Math.round(cacheAge / (24 * 60 * 60 * 1e3))} days` };
      }
    }
    return { isValid: true };
  }
  /**
   * Execute file operation with timeout and retry logic
   * @param operation The file operation to execute
   * @param operationName Description of the operation for logging
   * @param maxRetries Maximum number of retry attempts
   * @param timeoutMs Timeout in milliseconds for each attempt
   * @returns Promise that resolves to operation result
   */
  async executeFileOperationWithRetry(operation, operationName, maxRetries = FILE_OPERATIONS.MAX_RETRIES, timeoutMs = FILE_OPERATIONS.TIMEOUT_MS) {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`${operationName} timeout after ${timeoutMs}ms`)), timeoutMs);
        });
        const result = await Promise.race([
          operation(),
          timeoutPromise
        ]);
        return result;
      } catch (error) {
        handleFileError(error, operationName, `attempt ${attempt}/${maxRetries}`);
        if (attempt === maxRetries) {
          throw new Error(`${operationName} failed after ${maxRetries} attempts: ${error}`);
        }
        const backoffMs = Math.min(FILE_OPERATIONS.BASE_BACKOFF_MS * Math.pow(2, attempt - 1), FILE_OPERATIONS.MAX_BACKOFF_MS);
        await new Promise((resolve) => setTimeout(resolve, backoffMs));
      }
    }
    throw new Error(`Unexpected error in ${operationName}`);
  }
  /**
   * Smart text truncation that preserves complete words and sentences
   * @param text The text to truncate
   * @param maxLength Maximum character length
   * @returns Truncated text that preserves word/sentence boundaries
   */
  smartTruncateText(text, maxLength) {
    if (text.length <= maxLength) {
      return text;
    }
    const sentenceEnds = /[.!?]+\s+/g;
    let lastSentenceEnd = 0;
    let match;
    while ((match = sentenceEnds.exec(text)) !== null) {
      if (match.index + match[0].length > maxLength) {
        break;
      }
      lastSentenceEnd = match.index + match[0].length;
    }
    if (lastSentenceEnd > maxLength * TEXT_PROCESSING.SENTENCE_BOUNDARY_RATIO) {
      return text.substring(0, lastSentenceEnd);
    }
    const wordBoundary = /\s+/g;
    let lastWordEnd = 0;
    let wordMatch;
    while ((wordMatch = wordBoundary.exec(text)) !== null) {
      if (wordMatch.index > maxLength) {
        break;
      }
      lastWordEnd = wordMatch.index;
    }
    if (lastWordEnd > maxLength * TEXT_PROCESSING.WORD_BOUNDARY_RATIO) {
      return text.substring(0, lastWordEnd);
    }
    let truncateIndex = maxLength;
    while (truncateIndex > maxLength * TEXT_PROCESSING.TRUNCATION_FALLBACK_RATIO && truncateIndex < text.length && /\S/.test(text[truncateIndex])) {
      truncateIndex--;
    }
    return text.substring(0, truncateIndex);
  }
  /**
   * Deletes the cache file from disk
   * Used when cache is detected to be invalid
   */
  async deleteCache() {
    if (!this.cacheFilePath || !this.vault.adapter) {
      logIfDebugModeEnabled("Cannot delete cache: no cache path or vault adapter");
      return;
    }
    try {
      const exists = await this.executeFileOperationWithRetry(
        () => this.vault.adapter.exists((0, import_obsidian3.normalizePath)(this.cacheFilePath)),
        "Cache deletion check"
      );
      if (exists) {
        await this.executeFileOperationWithRetry(
          () => this.vault.adapter.remove((0, import_obsidian3.normalizePath)(this.cacheFilePath)),
          "Cache deletion operation"
        );
      }
    } catch (error) {
      console.error("Error deleting cache file:", error);
    }
  }
};

// src/main.ts
var RelatedNotesPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
    this.isInitialized = false;
    this.isReindexing = false;
    this.reindexCancelled = false;
    this.id = "obsidian-related-notes";
    this.lastStatusUpdate = 0;
    this.STATUS_UPDATE_THROTTLE_MS = 5e3;
    /**
     * Update the index for a single file
     * Uses a debounce mechanism to avoid excessive processing
     */
    this.fileUpdateQueue = /* @__PURE__ */ new Set();
    this.processingQueue = false;
    this.lastProcessTime = 0;
    this.PROCESS_INTERVAL = BATCH_PROCESSING.PROCESS_INTERVAL_MS;
    // 2 seconds between batches
    this.MAX_BATCH_SIZE = 5;
    // Process at most 5 files at once
    this.queueProcessingTimeout = null;
  }
  /**
   * Read file content with adaptive timeout and retry logic
   * @param file The file to read
   * @param maxRetries Maximum number of retry attempts
   * @param timeoutMs Timeout in milliseconds for each attempt (adaptive based on file size)
   * @returns Promise that resolves to file content
   */
  async readFileWithRetry(file, maxRetries = FILE_OPERATIONS.MAX_RETRIES, timeoutMs) {
    const baseTimeout = timeoutMs || FILE_OPERATIONS.READ_TIMEOUT_MS;
    let adaptiveTimeout;
    if (file.stat.size < 1024) {
      adaptiveTimeout = Math.min(baseTimeout * 0.5, 5e3);
    } else if (file.stat.size > 1024 * 1024) {
      adaptiveTimeout = baseTimeout * FILE_OPERATIONS.LARGE_FILE_TIMEOUT_MULTIPLIER;
    } else {
      adaptiveTimeout = baseTimeout;
    }
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        if (file.stat.size < 1024 && attempt === 1) {
          try {
            return await this.app.vault.cachedRead(file);
          } catch (quickError) {
          }
        }
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error(`File read timeout after ${adaptiveTimeout}ms (file size: ${file.stat.size} bytes)`)), adaptiveTimeout);
        });
        const content = await Promise.race([
          this.app.vault.cachedRead(file),
          timeoutPromise
        ]);
        return content;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (attempt === maxRetries) {
          logIfDebugModeEnabled(`File read failed after ${maxRetries} attempts: ${file.path} - ${errorMessage}`);
        }
        handleFileError(error, "read file", file.path);
        if (attempt === maxRetries) {
          throw new Error(`Failed to read file ${file.path} after ${maxRetries} attempts: ${errorMessage}`);
        }
        const backoffMs = Math.min(FILE_OPERATIONS.BASE_BACKOFF_MS * Math.pow(2, attempt - 1), FILE_OPERATIONS.MAX_BACKOFF_MS);
        await new Promise((resolve) => setTimeout(resolve, backoffMs));
      }
    }
    throw new Error(`Unexpected error in readFileWithRetry for ${file.path}`);
  }
  /**
   * Opens the plugin settings tab
   */
  openSettings() {
    var _a, _b;
    const app = this.app;
    if (((_a = app == null ? void 0 : app.setting) == null ? void 0 : _a.open) && ((_b = app == null ? void 0 : app.setting) == null ? void 0 : _b.openTabById)) {
      app.setting.open();
      app.setting.openTabById(this.id);
    } else {
      console.error("Settings interface not available");
    }
  }
  /**
   * Clears the cache files
   * This removes all cached data and allows starting fresh
   */
  async clearCache() {
    var _a, _b;
    try {
      const configDir = this.app.vault.configDir;
      const adapter = this.app.vault.adapter;
      if (!configDir || !adapter) {
        console.error("Could not access vault config directory");
        throw new Error("Could not access vault configuration");
      }
      const cachePaths = [
        // Current cache file
        `${configDir}/plugins/related-notes/.bloom-filter-cache.json`,
        // Legacy cache files
        `${configDir}/plugins/related-notes/bloom-filter-cache.json`,
        `${configDir}/plugins/related-notes/similarity-cache.json`,
        `${configDir}/plugins/related-notes/.index-cache.json`,
        `${configDir}/plugins/obsidian-related-notes/.bloom-filter-cache.json`,
        `${configDir}/plugins/obsidian-related-notes/bloom-filter-cache.json`,
        `${configDir}/plugins/obsidian-related-notes/similarity-cache.json`,
        `${configDir}/plugins/obsidian-related-notes/.index-cache.json`
      ];
      for (const cachePath of cachePaths) {
        try {
          const exists = await adapter.exists((0, import_obsidian4.normalizePath)(cachePath));
          if (exists) {
            await adapter.remove((0, import_obsidian4.normalizePath)(cachePath));
          }
        } catch (err) {
          console.error(`Failed to delete cache file ${cachePath}:`, err);
        }
      }
      if (this.similarityProvider) {
        if (this.similarityProvider instanceof MultiResolutionBloomFilterProvider) {
          (_a = this.similarityProvider) == null ? void 0 : _a.clear();
        }
      }
      (_b = this.statusBarItem) == null ? void 0 : _b.setText("Cache cleared");
      if (this.statusBarItem) {
        this.statusBarItem.style.display = "block";
      }
      setTimeout(() => {
        this.updateFileCountStatus();
      }, 3e3);
      this.isInitialized = false;
      setTimeout(() => {
        this.initializeSimilarityProvider();
      }, 1e3);
    } catch (error) {
      console.error("Error clearing cache:", error);
      throw error;
    }
  }
  async onload() {
    await this.loadSettings();
    setDebugMode(this.settings.debugMode);
    this.registerCommands();
    this.addSettingTab(new RelatedNotesSettingTab(this.app, this));
    this.app.workspace.onLayoutReady(async () => {
      await this.initializePlugin();
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    setDebugMode(this.settings.debugMode);
  }
  async initializePlugin() {
    var _a;
    this.registerView(
      RELATED_NOTES_VIEW_TYPE,
      (leaf) => new RelatedNotesView(leaf, this)
    );
    this.addRibbonIcon(
      "zap",
      "Toggle related notes",
      () => this.toggleRelatedNotes(this.app.workspace)
    );
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.style.display = "none";
    this.registerEventHandlers();
    this.isInitialized = false;
    const configDir = this.app.vault.configDir;
    try {
      const oldCachePaths = [
        `${configDir}/plugins/related-notes/similarity-cache.json`,
        `${configDir}/plugins/related-notes/bloom-filter-cache.json`,
        // Non-hidden version
        `${configDir}/plugins/obsidian-related-notes/similarity-cache.json`,
        `${configDir}/plugins/obsidian-related-notes/bloom-filter-cache.json`
        // Non-hidden version
      ];
      for (const oldCachePath of oldCachePaths) {
        await this.app.vault.adapter.remove(oldCachePath).catch(() => {
        });
      }
      this.settings.lastKnownVersion = this.manifest.version;
      await this.saveSettings();
    } catch (error) {
    }
    const totalFiles = this.app.vault.getMarkdownFiles().length;
    const isLargeVault = totalFiles > WORD_FILTERING.LARGE_VAULT_THRESHOLD;
    const defaultSize = isLargeVault ? BLOOM_FILTER.LARGE_VAULT_FILTER_SIZE : BLOOM_FILTER.DEFAULT_FILTER_SIZE;
    const bloomSizes = this.settings.ngramSizes.map(() => defaultSize);
    const defaultWeights = this.settings.ngramSizes.map(() => 1);
    let hashFunctions = this.settings.hashFunctions;
    if (!hashFunctions || hashFunctions.length !== this.settings.ngramSizes.length) {
      hashFunctions = this.settings.ngramSizes.map(() => 3);
    }
    this.similarityProvider = new MultiResolutionBloomFilterProvider(this.app.vault, {
      ngramSizes: this.settings.ngramSizes,
      bloomSizes,
      // Use consistent bloom sizes to prevent size mismatch errors
      hashFunctions,
      weights: defaultWeights,
      // Use consistent weights to ensure valid comparisons
      adaptiveParameters: true,
      // Always use adaptive parameters
      similarityThreshold: this.settings.similarityThreshold,
      commonWordsThreshold: this.settings.commonWordsThreshold,
      maxStopwords: this.settings.maxStopwords,
      priorityIndexSize: this.settings.priorityIndexSize,
      batchSize: this.settings.batchSize,
      // Sampling settings
      enableSampling: this.settings.enableSampling,
      sampleSizeThreshold: this.settings.sampleSizeThreshold,
      maxSampleSize: this.settings.maxSampleSize,
      // Fast word-based candidate selection (auto-enabled for medium+ vaults)
      useWordBasedCandidates: (() => {
        const totalFiles2 = this.app.vault.getMarkdownFiles().length;
        const threshold = WORD_FILTERING.WORD_INDEX_THRESHOLD;
        const useWordIndex = totalFiles2 > threshold;
        if (useWordIndex) {
          logIfDebugModeEnabled(`Using word-based indexing for ${totalFiles2} files (>${threshold} threshold)`);
        } else {
          logIfDebugModeEnabled(`Using bloom filter indexing for ${totalFiles2} files (\u2264${threshold} threshold)`);
        }
        return useWordIndex;
      })()
    });
    (_a = this.statusBarItem) == null ? void 0 : _a.setText("Loading index...");
    if (this.statusBarItem) {
      this.statusBarItem.style.display = "block";
    }
    this.setupPeriodicCacheSave();
    setTimeout(() => {
      this.initializeSimilarityProvider();
    }, 1e3);
  }
  // Update status bar at most every 5ms
  async initializeSimilarityProvider() {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      await ((_a = this.similarityProvider) == null ? void 0 : _a.initialize((processed, total, currentFile) => {
        var _a2, _b2, _c2;
        const now = Date.now();
        if (now - this.lastStatusUpdate < this.STATUS_UPDATE_THROTTLE_MS && processed < total) {
          return;
        }
        this.lastStatusUpdate = now;
        const percentage = Math.round(processed / total * 100);
        const totalFiles = this.app.vault.getMarkdownFiles().length;
        const isLargeVault = totalFiles > WORD_FILTERING.LARGE_VAULT_THRESHOLD;
        let message = "";
        let hoverText = "";
        if (processed === 0 && total > 0) {
          message = `Checking cache...`;
          hoverText = "Loading existing index from cache";
        } else if (processed === 0) {
          if (isLargeVault) {
            message = `Preparing large vault (${totalFiles} files)...`;
            hoverText = "Preparing to index files in large vault";
          } else {
            message = `Indexing ${total} files...`;
            hoverText = "Starting to index files";
          }
        } else if (processed === total) {
          if (isLargeVault) {
            message = `Related notes ready! (${total})`;
            hoverText = "Indexing complete - related notes are available";
          } else {
            message = `Indexed ${total} files`;
            hoverText = "Indexing complete";
          }
        } else {
          message = `Indexing: ${percentage}% (${processed}/${total})`;
          if (currentFile) {
            const fileName = currentFile.split("/").pop() || currentFile;
            hoverText = `Currently indexing: ${fileName}`;
          } else {
            hoverText = `Processing ${processed} of ${total} files`;
          }
        }
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText(message);
        (_b2 = this.statusBarItem) == null ? void 0 : _b2.setAttribute("aria-label", hoverText);
        (_c2 = this.statusBarItem) == null ? void 0 : _c2.setAttribute("title", hoverText);
        if (this.statusBarItem) {
          this.statusBarItem.style.display = "block";
        }
      }));
      const stats = (_b = this.similarityProvider) == null ? void 0 : _b.getStats();
      if ((stats == null ? void 0 : stats.indexing) && stats.indexing.currentFile) {
        const currentFile = stats.indexing.currentFile;
        const fileName = currentFile.split("/").pop() || currentFile;
        const progressTitle = `Currently indexing: ${fileName}`;
        (_c = this.statusBarItem) == null ? void 0 : _c.setText("Indexing...");
        (_d = this.statusBarItem) == null ? void 0 : _d.setAttribute("aria-label", progressTitle);
        (_e = this.statusBarItem) == null ? void 0 : _e.setAttribute("title", progressTitle);
        if (this.statusBarItem) {
          this.statusBarItem.style.display = "block";
        }
        setTimeout(() => this.updateProgressiveIndexingStatus(), 3e4);
      } else {
        this.updateFileCountStatus();
      }
      if (this.similarityProvider && this.similarityProvider.stopRequested) {
        (_f = this.statusBarItem) == null ? void 0 : _f.setText("Indexing cancelled");
        setTimeout(() => {
          var _a2;
          (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
          if (this.statusBarItem) {
            this.statusBarItem.style.display = "none";
          }
        }, 2e3);
      }
      this.isInitialized = true;
    } catch (error) {
      console.error("Error during initialization:", error);
      (_g = this.statusBarItem) == null ? void 0 : _g.setText("Indexing error");
      setTimeout(() => {
        var _a2;
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
        if (this.statusBarItem) {
          this.statusBarItem.style.display = "none";
        }
      }, 3e3);
      this.isInitialized = true;
    }
  }
  /**
   * Forces a complete re-indexing of all notes
   * Simple implementation focused on not crashing
   */
  async forceReindex() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    if (this.isReindexing) {
      logIfDebugModeEnabled("Reindex already in progress - request ignored");
      return;
    }
    if (!this.isInitialized) {
      (_a = this.statusBarItem) == null ? void 0 : _a.setText("Initial indexing in progress");
      if (this.statusBarItem) {
        this.statusBarItem.style.display = "block";
      }
      setTimeout(() => {
        var _a2;
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("Indexing in progress");
        if (this.statusBarItem) {
          this.statusBarItem.style.display = "block";
        }
      }, 1e3);
      return;
    }
    this.isReindexing = true;
    this.reindexCancelled = false;
    try {
      this.isInitialized = false;
      (_b = this.statusBarItem) == null ? void 0 : _b.setText("Indexing notes");
      if (this.statusBarItem) {
        this.statusBarItem.style.display = "block";
      }
      let lastCheckTime = Date.now();
      const checkCancellation = async () => {
        const now = Date.now();
        if (now - lastCheckTime < 500)
          return;
        lastCheckTime = now;
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            if (this.reindexCancelled) {
              reject(new Error("Indexing cancelled"));
            } else {
              resolve();
            }
          }, 0);
        });
      };
      await ((_c = this.similarityProvider) == null ? void 0 : _c.forceReindex(async (processed, total, currentFile) => {
        var _a2, _b2, _c2;
        try {
          if (processed % 10 === 0) {
            await checkCancellation();
          }
          const percentage = Math.min(100, Math.round(processed / Math.max(1, total) * 100));
          let message = "";
          let phase = "Indexing";
          message = `${phase} notes: ${percentage}%`;
          let hoverText = `${phase} ${processed} of ${total} notes`;
          if (currentFile) {
            const fileName = currentFile.split("/").pop() || currentFile;
            hoverText = `Currently processing: ${fileName}`;
          }
          (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText(message);
          (_b2 = this.statusBarItem) == null ? void 0 : _b2.setAttribute("aria-label", hoverText);
          (_c2 = this.statusBarItem) == null ? void 0 : _c2.setAttribute("title", hoverText);
          if (this.statusBarItem) {
            this.statusBarItem.style.display = "block";
          }
        } catch (error) {
          if (error instanceof Error && error.message === "Indexing cancelled") {
            throw error;
          }
          console.error("Error during progress update:", error);
        }
      }));
      (_d = this.statusBarItem) == null ? void 0 : _d.setText("Indexing complete");
      setTimeout(() => {
        this.updateFileCountStatus();
      }, 3e3);
      (_e = this.statusBarItem) == null ? void 0 : _e.removeAttribute("aria-label");
      (_f = this.statusBarItem) == null ? void 0 : _f.removeAttribute("title");
      this.isInitialized = true;
      const leaves = this.app.workspace.getLeavesOfType(RELATED_NOTES_VIEW_TYPE);
      if (leaves.length > 0) {
        const view = leaves[0].view;
        if (view instanceof RelatedNotesView) {
          const activeView = (_g = this.app.workspace.getMostRecentLeaf()) == null ? void 0 : _g.view;
          if (activeView instanceof import_obsidian4.MarkdownView && activeView.file) {
            await this.showRelatedNotes(this.app.workspace, activeView.file);
          }
        }
      }
    } catch (error) {
      if (error instanceof Error && error.message === "Indexing cancelled") {
        (_h = this.statusBarItem) == null ? void 0 : _h.setText("Re-indexing cancelled");
        setTimeout(() => {
          var _a2;
          (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
          if (this.statusBarItem) {
            this.statusBarItem.style.display = "none";
          }
        }, 2e3);
        this.isInitialized = true;
      } else {
        console.error("Error during re-indexing:", error);
        (_i = this.statusBarItem) == null ? void 0 : _i.setText("Error during re-indexing");
        setTimeout(() => {
          var _a2;
          (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
          if (this.statusBarItem) {
            this.statusBarItem.style.display = "none";
          }
        }, 2e3);
        this.isInitialized = true;
      }
    } finally {
      this.isReindexing = false;
    }
  }
  /**
   * Cancels the current re-indexing operation
   */
  cancelReindex() {
    var _a, _b;
    if (this.isReindexing) {
      this.reindexCancelled = true;
      (_a = this.similarityProvider) == null ? void 0 : _a.stop();
      (_b = this.statusBarItem) == null ? void 0 : _b.setText("Indexing cancelled");
      setTimeout(() => {
        var _a2;
        (_a2 = this.statusBarItem) == null ? void 0 : _a2.setText("");
        if (this.statusBarItem) {
          this.statusBarItem.style.display = "none";
        }
      }, 2e3);
      this.isInitialized = true;
    }
  }
  registerEventHandlers() {
    this.registerEvent(
      this.app.workspace.on(
        "file-open",
        (file) => this.showRelatedNotes(this.app.workspace, file)
      )
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian4.TFile && this.isMarkdownFile(file)) {
          this.updateIndexForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian4.TFile && this.isMarkdownFile(file)) {
          this.updateIndexForFile(file);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian4.TFile && this.isMarkdownFile(file)) {
          if (this.similarityProvider instanceof MultiResolutionBloomFilterProvider) {
            const provider = this.similarityProvider;
            if (provider.wordCandidateSelector && provider.useWordBasedCandidates) {
              provider.wordCandidateSelector.removeDocument(file.path);
            }
            provider.cacheDirty = true;
          }
          setTimeout(() => this.updateFileCountStatus(), 100);
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("quit", async () => {
        if (this.similarityProvider instanceof MultiResolutionBloomFilterProvider) {
          try {
            await this.similarityProvider.saveCache();
            console.info("[RelatedNotes] Cache saved before app quit");
          } catch (error) {
            console.error("[RelatedNotes] Failed to save cache before app quit:", error);
          }
        }
      })
    );
  }
  async updateIndexForFile(file) {
    if (!this.isInitialized || !this.similarityProvider)
      return;
    this.fileUpdateQueue.add(file.path);
    if (!this.processingQueue) {
      this.processingQueue = true;
      this.processFileQueue();
    }
  }
  async processFileQueue() {
    var _a;
    const now = Date.now();
    const timeSinceLastProcess = now - this.lastProcessTime;
    if (timeSinceLastProcess < this.PROCESS_INTERVAL && this.lastProcessTime > 0) {
      await new Promise(
        (resolve) => setTimeout(resolve, this.PROCESS_INTERVAL - timeSinceLastProcess)
      );
    }
    if (this.fileUpdateQueue.size === 0) {
      this.processingQueue = false;
      return;
    }
    this.lastProcessTime = Date.now();
    const batch = Array.from(this.fileUpdateQueue).slice(0, this.MAX_BATCH_SIZE);
    for (const filePath of batch) {
      this.fileUpdateQueue.delete(filePath);
    }
    for (const filePath of batch) {
      try {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian4.TFile) {
          const content = await this.readFileWithRetry(file);
          const fileName = file.basename;
          const enhancedContent = `${fileName} ${content}`;
          await new Promise((resolve) => setTimeout(resolve, 10));
          await ((_a = this.similarityProvider) == null ? void 0 : _a.processDocument(file.path, enhancedContent));
        }
      } catch (error) {
        handleIndexingError(error, filePath, { operation: "file index update" });
      }
    }
    if (this.fileUpdateQueue.size > 0) {
      this.processFileQueue();
    } else {
      this.processingQueue = false;
      this.updateFileCountStatus();
    }
  }
  registerCommands() {
    this.addCommand({
      id: "toggle-related-notes",
      name: "Toggle related notes",
      checkCallback: (checking) => {
        if (!checking) {
          this.toggleRelatedNotes(this.app.workspace);
        }
        return true;
      }
    });
  }
  async onunload() {
    var _a;
    if (this.similarityProvider) {
      try {
        (_a = this.similarityProvider) == null ? void 0 : _a.stop();
      } catch (error) {
        handleUIError(error, "plugin unload", "stop operations");
      }
    }
    if (this.isReindexing) {
      this.cancelReindex();
    }
    this.fileUpdateQueue.clear();
    this.processingQueue = false;
    if (this.queueProcessingTimeout) {
      clearTimeout(this.queueProcessingTimeout);
      this.queueProcessingTimeout = null;
    }
    if (this.cacheSaveInterval) {
      clearInterval(this.cacheSaveInterval);
      this.cacheSaveInterval = void 0;
    }
    if (this.similarityProvider instanceof MultiResolutionBloomFilterProvider) {
      try {
        await Promise.race([
          this.similarityProvider.saveCache(),
          new Promise(
            (_, reject) => setTimeout(() => reject(new Error("Cache save timeout")), 5e3)
          )
        ]);
        console.info("[RelatedNotes] Cache saved on plugin disable");
      } catch (error) {
        handleUIError(error, "plugin unload", "save cache");
      }
    }
    this.similarityProvider = void 0;
    this.isInitialized = false;
    this.isReindexing = false;
    this.reindexCancelled = false;
  }
  async toggleRelatedNotes(workspace) {
    const leaves = workspace.getLeavesOfType(RELATED_NOTES_VIEW_TYPE);
    if (leaves.length > 0) {
      workspace.detachLeavesOfType(RELATED_NOTES_VIEW_TYPE);
      return;
    }
    await this.createAndInitializeView();
  }
  async createAndInitializeView() {
    var _a;
    const leaf = this.app.workspace.getRightLeaf(false);
    if (!leaf)
      return;
    await leaf.setViewState({ type: RELATED_NOTES_VIEW_TYPE, active: true });
    const view = leaf.view;
    if (!(view instanceof RelatedNotesView))
      return;
    const activeView = (_a = this.app.workspace.getMostRecentLeaf()) == null ? void 0 : _a.view;
    if (activeView instanceof import_obsidian4.MarkdownView && activeView.file) {
      await this.showRelatedNotes(this.app.workspace, activeView.file);
    } else {
      await view.reset();
    }
    this.app.workspace.revealLeaf(leaf);
  }
  isMarkdownFile(file) {
    return file.extension.toLowerCase() === "md";
  }
  isInitializationComplete() {
    return this.isInitialized;
  }
  /**
   * Checks if re-indexing is currently in progress
   */
  isReindexingInProgress() {
    return this.isReindexing;
  }
  /**
   * Updates the status bar with indexing information
   * Called periodically to refresh the status
   */
  updateProgressiveIndexingStatus() {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.isInitialized)
      return;
    const stats = (_a = this.similarityProvider) == null ? void 0 : _a.getStats();
    if ((stats == null ? void 0 : stats.indexing) && stats.indexing.currentFile) {
      const currentFile = stats.indexing.currentFile;
      const fileName = currentFile.split("/").pop() || currentFile;
      const progressTitle = `Currently indexing: ${fileName}`;
      (_b = this.statusBarItem) == null ? void 0 : _b.setText("Indexing...");
      (_c = this.statusBarItem) == null ? void 0 : _c.setAttribute("aria-label", progressTitle);
      (_d = this.statusBarItem) == null ? void 0 : _d.setAttribute("title", progressTitle);
      if (this.statusBarItem) {
        this.statusBarItem.style.display = "block";
      }
      setTimeout(() => this.updateProgressiveIndexingStatus(), 3e4);
    } else {
      (_e = this.statusBarItem) == null ? void 0 : _e.setText("");
      (_f = this.statusBarItem) == null ? void 0 : _f.removeAttribute("aria-label");
      (_g = this.statusBarItem) == null ? void 0 : _g.removeAttribute("title");
      if (this.statusBarItem) {
        this.statusBarItem.style.display = "none";
      }
    }
  }
  /**
   * Set up periodic cache saving to preserve indexing work
   */
  setupPeriodicCacheSave() {
    this.cacheSaveInterval = window.setInterval(async () => {
      if (this.similarityProvider instanceof MultiResolutionBloomFilterProvider && this.isInitialized) {
        try {
          const provider = this.similarityProvider;
          if (provider.cacheDirty) {
            await provider.saveCache();
            logIfDebugModeEnabled("Periodic cache save completed");
          }
        } catch (error) {
          console.warn("Periodic cache save failed:", error);
        }
      }
    }, 5 * 60 * 1e3);
    this.registerInterval(this.cacheSaveInterval);
  }
  /**
   * Update the status bar to show the number of indexed files
   */
  updateFileCountStatus() {
    if (!this.statusBarItem || !this.similarityProvider) {
      return;
    }
    const stats = this.similarityProvider.getStats();
    const indexedCount = typeof stats.documentsProcessed === "number" ? stats.documentsProcessed : 0;
    const totalFiles = this.app.vault.getMarkdownFiles().length;
    if (indexedCount > 0) {
      const statusText = `${indexedCount} notes indexed`;
      const hoverText = `Related Notes: ${indexedCount} of ${totalFiles} notes indexed and ready for similarity search`;
      this.statusBarItem.setText(statusText);
      this.statusBarItem.setAttribute("aria-label", hoverText);
      this.statusBarItem.setAttribute("title", hoverText);
      this.statusBarItem.style.display = "block";
    } else {
      this.statusBarItem.setText("");
      this.statusBarItem.removeAttribute("aria-label");
      this.statusBarItem.removeAttribute("title");
      this.statusBarItem.style.display = "none";
    }
  }
  async showRelatedNotes(workspace, file) {
    if (!(file instanceof import_obsidian4.TFile))
      return;
    const leaves = workspace.getLeavesOfType(RELATED_NOTES_VIEW_TYPE);
    if (leaves.length === 0)
      return;
    const view = leaves[0].view;
    if (!(view instanceof RelatedNotesView))
      return;
    const relatedNotes = await this.getRelatedNotes(file);
    await view.updateForFile(file, relatedNotes);
  }
  async getRelatedNotes(file) {
    var _a;
    try {
      const candidates = await ((_a = this.similarityProvider) == null ? void 0 : _a.getCandidateFiles(file)) || [];
      const similarityPromises = candidates.map(async (candidate) => {
        var _a2;
        try {
          const similarity = await ((_a2 = this.similarityProvider) == null ? void 0 : _a2.computeCappedCosineSimilarity(file, candidate));
          return {
            file: candidate,
            similarity: (similarity == null ? void 0 : similarity.similarity) || 0,
            isPreIndexed: true
          };
        } catch (error) {
          console.warn(`Error computing similarity for ${candidate.path}:`, error);
          return {
            file: candidate,
            similarity: 0,
            isPreIndexed: true
          };
        }
      });
      const relatedNotes = await Promise.all(similarityPromises);
      const sortedNotes = relatedNotes.filter((note) => note.similarity > 0).sort((a, b) => b.similarity - a.similarity);
      if (sortedNotes.length > 0) {
        return sortedNotes.slice(0, this.settings.maxSuggestions);
      }
    } catch (error) {
      console.error(`Error getting related notes for ${file.path}:`, error);
    }
    return [];
  }
};

/* nosourcemap */